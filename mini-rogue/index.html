<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ãƒŸãƒ‹ãƒ­ãƒ¼ã‚°+ï¼šå®ç®±ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒ»3æŠ</title>
  <style>
    :root{
      --bg:#0b1020; --card:#121a33; --text:#e8ecff; --muted:#a8b0d6;
      --accent:#66e3ff; --ok:#6dff9b; --bad:#ff6b8a; --warn:#ffd36d;
      --shadow:0 12px 30px rgba(0,0,0,.35); --r:18px;
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent;}
    body{
      margin:0; min-height:100vh; display:flex; justify-content:center; align-items:center;
      padding:16px; color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;
      background: radial-gradient(1000px 700px at 20% 10%, #1b2a63 0%, transparent 55%),
                  radial-gradient(900px 700px at 90% 20%, #1e5a5f 0%, transparent 55%),
                  var(--bg);
    }
    .app{
      width:min(640px,100%);
      background: rgba(18,26,51,.86);
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    header{padding:18px 18px 10px; border-bottom:1px solid rgba(255,255,255,.08);}
    h1{margin:0 0 6px; font-size:18px;}
    .sub{margin:0; color:var(--muted); font-size:13px; line-height:1.4;}
    main{padding:16px 18px 18px;}
    .card{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:14px;}
    .stats{display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px;}
    .stat{background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.06); border-radius:14px; padding:12px;}
    .label{color:var(--muted); font-size:12px;}
    .value{font-size:20px; font-weight:900; margin-top:4px;}
    .bar{height:10px; border-radius:999px; background:rgba(0,0,0,.25); border:1px solid rgba(255,255,255,.06); overflow:hidden; margin-top:8px;}
    .bar > div{height:100%; width:50%; background:linear-gradient(90deg,var(--accent),#7cffc9); transition:width .2s;}
    .pill{display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:900; border:1px solid rgba(255,255,255,.12); margin-right:6px;}
    .pill.ok{background:rgba(109,255,155,.14); border-color:rgba(109,255,155,.35);}
    .pill.bad{background:rgba(255,107,138,.14); border-color:rgba(255,107,138,.35);}
    .pill.neu{background:rgba(102,227,255,.12); border-color:rgba(102,227,255,.35);}
    .pill.warn{background:rgba(255,211,109,.12); border-color:rgba(255,211,109,.35);}
    .log{min-height:120px; line-height:1.65;}
    .log small{color:var(--muted);}
    .choices{display:grid; gap:10px; grid-template-columns:1fr; margin-top:12px;}
    button{
      border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.06);
      color:var(--text); border-radius:16px; padding:14px 14px; font-weight:900; font-size:15px;
      text-align:left;
    }
    button:active{transform:translateY(1px);}
    .primary{background:rgba(102,227,255,.16); border-color:rgba(102,227,255,.35);}
    .okbtn{background:rgba(109,255,155,.12); border-color:rgba(109,255,155,.35);}
    .badbtn{background:rgba(255,107,138,.12); border-color:rgba(255,107,138,.35);}
    .warnbtn{background:rgba(255,211,109,.12); border-color:rgba(255,211,109,.35);}
    .muted{color:var(--muted);}
    .footer{display:flex; gap:10px; margin-top:12px; flex-wrap:wrap;}
    .footer button{flex:1 1 160px; text-align:center;}
    .list{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;}
    .tag{
      padding:6px 10px; border-radius:999px; font-size:12px; font-weight:900;
      background:rgba(0,0,0,.18); border:1px solid rgba(255,255,255,.08);
    }
    /* ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã¯è² ã‘ãŸæ™‚ã ã‘è¡¨ç¤ºï¼ˆJSã§åˆ‡æ›¿ï¼‰ */
    #restart{ display:none; }
    /* ===== æˆ¦é—˜ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ« ===== */
    .stage{
      margin-top:12px;
      position:relative;
      height:230px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.08);
      background:
        radial-gradient(500px 200px at 30% 10%, rgba(102,227,255,.18), transparent 60%),
        radial-gradient(500px 220px at 80% 30%, rgba(109,255,155,.14), transparent 60%),
        rgba(0,0,0,.18);
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      padding:12px;
    }
    
    .sprite{
      position:relative;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      width:48%;
      height:100%;
    }
    
    .sprite img{
      max-height:100%;
      max-width:100%;
      object-fit:contain;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      transform-origin: bottom center;
    }
    
    /* è‡ªã‚­ãƒ£ãƒ©ã¯å°‘ã—å¯„ã›ã‚‹ */
    .sprite.player{ justify-content:flex-start; }
    .sprite.enemy{ justify-content:flex-end; }

    #enemyWrap{
      opacity:0;
      transform: translateX(12px);
      transition: opacity .2s ease, transform .2s ease;
    }
    #enemyWrap.hidden{
      opacity:0;
      pointer-events:none;
      transform: translateX(12px);
    }
    #enemyWrap:not(.hidden){
      opacity:1;
      transform: translateX(0);
    }
    
    /* ãƒœã‚¹æ„Ÿï¼šã¡ã‚‡ã„å¤§ããï¼‹ç™ºå…‰ */
    #enemyWrap.boss img{
      transform: scale(1.06);
      filter: drop-shadow(0 0 18px rgba(255,211,109,.25)) drop-shadow(0 10px 18px rgba(0,0,0,.45));
    }
    
    .stageHud{
      position:absolute;
      left:12px; right:12px; top:10px;
      display:flex;
      justify-content:flex-end;
      pointer-events:none;
    }
    .enemyName{
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:900;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      color: rgba(232,236,255,.95);
    }
    
    /* ===== ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ ===== */
    @keyframes lungePlayer{
      0%{ transform: translateX(0) scale(1); }
      45%{ transform: translateX(10px) scale(1.02); }
      100%{ transform: translateX(0) scale(1); }
    }
    @keyframes lungeEnemy{
      0%{ transform: translateX(0) scale(1); }
      45%{ transform: translateX(-10px) scale(1.02); }
      100%{ transform: translateX(0) scale(1); }
    }
    @keyframes hitFlash{
      0%{ filter: brightness(1) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
      30%{ filter: brightness(1.8) drop-shadow(0 0 14px rgba(255,107,138,.35)) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
      100%{ filter: brightness(1) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
    }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-3px); }
      50%{ transform: translateX(3px); }
      75%{ transform: translateX(-2px); }
      100%{ transform: translateX(0); }
    }
    @keyframes healGlow{
      0%{ filter: brightness(1) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
      35%{ filter: brightness(1.4) drop-shadow(0 0 18px rgba(109,255,155,.35)) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
      100%{ filter: brightness(1) drop-shadow(0 10px 18px rgba(0,0,0,.45)); }
    }
    @keyframes idleFloat {
      0%   { transform: translateY(0) scale(1); }
      50%  { transform: translateY(-4px) scale(1.01); }
      100% { transform: translateY(0) scale(1); }
    }
    @keyframes knockbackEnemy {
      0%   { transform: translateX(0); }
      40%  { transform: translateX(10px); }
      100% { transform: translateX(0); }
    }
    @keyframes knockbackPlayer {
      0%   { transform: translateX(0); }
      40%  { transform: translateX(-10px); }
      100% { transform: translateX(0); }
    }

    #enemyWrap.knockback img  { animation: knockbackEnemy .2s ease-out 1; }
    #playerWrap.knockback img { animation: knockbackPlayer .2s ease-out 1; }
    #playerWrap.idle:not(.attack):not(.hurt):not(.knockback) img {
      animation: idleFloat 1.8s ease-in-out infinite;
    }
    #enemyWrap.idle:not(.attack):not(.hurt):not(.knockback) img {
      animation: idleFloat 2.1s ease-in-out infinite;
    }
  
    #playerWrap.attack img{ animation: lungePlayer .22s ease-out 1; }
    #enemyWrap.attack img{ animation: lungeEnemy .22s ease-out 1; }
    
    #playerWrap.hurt img, #enemyWrap.hurt img{ animation: hitFlash .26s ease-out 1; }
    #playerWrap.shake, #enemyWrap.shake{ animation: shake .28s ease-out 1; }
    #playerWrap.heal img{ animation: healGlow .35s ease-out 1; }

    /* hurt + knockback ã‚’åŒæ™‚ã«èµ°ã‚‰ã›ã‚‹ */
    #enemyWrap.hurt.knockback img{
      animation: hitFlash .26s ease-out 1, knockbackEnemy .18s ease-out 1;
    }
    #playerWrap.hurt.knockback img{
      animation: hitFlash .26s ease-out 1, knockbackPlayer .18s ease-out 1;
    }
    
    /* @media (prefers-reduced-motion: reduce){
      #playerWrap.attack img, #enemyWrap.attack img,
      #playerWrap.hurt img, #enemyWrap.hurt img,
      #playerWrap.shake, #enemyWrap.shake,
      #playerWrap.heal img{
        animation: none !important;
      }
    } */
    .pickRow{
      display:flex;
      gap:12px;
      align-items:center;
    }
    .pickThumb{
      width:64px;
      height:64px;
      border-radius:14px;
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      flex:0 0 auto;
    }
    .pickThumb img{
      width:100%;
      height:100%;
      object-fit:contain;
    }
    /* ===== ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å­—ï¼ˆé£›ã³æ–‡å­—ï¼‰ ===== */
    .floatLayer{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow:hidden;
    }
    
    .floatText{
      position:absolute;
      padding:6px 10px;
      border-radius:999px;
      font-weight:900;
      font-size:14px;
      line-height:1;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      transform: translate(-50%, -50%);
      will-change: transform, opacity;
      animation: floatUp .65s ease-out forwards;
      text-shadow: 0 2px 10px rgba(0,0,0,.5);
    }
    
    .floatText.dmg { color: var(--bad); }
    .floatText.heal{ color: var(--ok); }
    .floatText.block{ color: var(--accent); }
    .floatText.dot { color: var(--warn); } /* æ¯’/ç«å‚·ãªã© */
    
    @keyframes floatUp{
      0%   { opacity:0; transform: translate(-50%, -50%) translateY(8px) scale(.95); }
      15%  { opacity:1; transform: translate(-50%, -50%) translateY(0) scale(1); }
      100% { opacity:0; transform: translate(-50%, -50%) translateY(-38px) scale(1.02); }
    }
    
    /* ã¡ã‚‡ã„æ´¾æ‰‹ç‰ˆï¼ˆã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã£ã½ã„ï¼‰ */
    .floatText.big{
      font-size:18px;
      padding:7px 12px;
      border-color: rgba(255,211,109,.35);
      box-shadow: 0 0 18px rgba(255,211,109,.12);
    }

    /* ===== Live2D layer ===== */
    #live2dWrap {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      min-width: 200px;
      min-height: 200px;
      z-index: 2;
      pointer-events: none;
      opacity: 0.98;
      background: none;
    }
    #live2dWrap.hidden{ display:none; }
    @media (max-width: 560px){
      #live2dWrap{ width: 260px; height: 420px; }
    }
    
  </style>
</head>
<body>
<!-- Live2Dè¡¨ç¤ºï¼ˆå·¦å´å›ºå®šï¼‰ -->
<div class="app">
  <header>
    <h1>ãƒŸãƒ‹ãƒ­ãƒ¼ã‚°+ï¼ˆå®ç®±ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆãƒ»3æŠï¼‰</h1>
    <p class="sub">å„éšã§<b>3ã¤ã®æ‰‰</b>ã‚’é¸ã‚“ã§é€²ã‚€ã€‚<b>4éš/8éšã¯ãƒœã‚¹</b>ï¼ˆå¼·æ•µï¼‹ç¢ºå®šãƒ¬ãƒªãƒƒã‚¯ï¼‰ã€‚<b>8éšçªç ´</b>ã§å‹åˆ©ï¼</p>
  </header>
  <main>
    <section class="card">
      <div class="stats">
        <div class="stat">
          <div class="label">ã‚ãªãŸ</div>
          <div class="value"><span id="hp">20</span>/<span id="maxhp">20</span> HP</div>
          <div class="bar"><div id="hpbar"></div></div>
          <div class="muted" style="margin-top:8px;font-size:12px;">
            é˜²å¾¡: <b id="block">0</b> / ã‚³ã‚¤ãƒ³: <b id="gold">0</b><br>
            é›†ä¸­: <b id="focus">0</b>/<b id="focusMax">6</b>
            <span class="muted"> / ãƒ–ãƒ¬ã‚¤ã‚¯CD: <b id="breakCD">0</b></span><br>
            çŠ¶æ…‹: <b id="pstatus">ãªã—</b>
            <br>ãƒãƒ¼ã‚·ãƒ§ãƒ³: <b id="potion">ãªã—</b>
          </div>
        </div>
        <div class="stat">
          <div class="label">æ•µ</div>
          <div class="value"><span id="ehp">-</span>/<span id="emaxhp">-</span> HP</div>
          <div class="bar"><div id="ehpbar"></div></div>
          <div class="muted" style="margin-top:8px;font-size:12px;">äºˆå®šæ”»æ’ƒ: <b id="eintent">-</b><br>çŠ¶æ…‹: <b id="estatus">ãªã—</b></div>
        </div>
        <div class="stat">
          <div class="label">é€²è¡Œ</div>
          <div class="value">éšå±¤ <span id="floor">1</span> / <span id="goal">8</span></div>
          <div class="muted" style="margin-top:8px;font-size:12px;">å‹åˆ©æ•°: <b id="wins">0</b></div>
        </div>
      </div>
      <div class="list" id="relics"></div>
      <!-- â–¼ æˆ¦é—˜ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ï¼ˆã‚­ãƒ£ãƒ©è¡¨ç¤ºï¼‰ -->
      <div class="stage" id="stage">
        <div class="sprite player" id="playerWrap">
          <img id="playerImg" src="./assets/player.png" alt="Player">
          <div id="live2dWrap" aria-hidden="true" class="hidden"></div>
        </div>
      
        <div class="sprite enemy" id="enemyWrap" aria-hidden="true">
          <img id="enemyImg" src="./assets/enemy.png" alt="Enemy">
        </div>
      
        <div class="stageHud">
          <div class="enemyName" id="enemyName"></div>
        </div>

        <!-- âœ… è¿½åŠ ï¼šãƒ€ãƒ¡ãƒ¼ã‚¸è¡¨ç¤ºç”¨ãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
        <div class="floatLayer" id="floatLayer"></div>
        
      </div>
      <!-- â–² æˆ¦é—˜ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ« -->
    </section>

    <!-- â–¼ ã‚­ãƒ£ãƒ©é¸æŠï¼ˆã‚²ãƒ¼ãƒ é–‹å§‹å‰ï¼‰ -->
    <div class="card" id="pickCard" style="margin-top:12px; display:none;">
      <div class="log">
        <span class="pill neu">ã‚­ãƒ£ãƒ©é¸æŠ</span>
        æœ€åˆã«ä½¿ã†ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚
      </div>
      <div class="choices" id="pickChoices"></div>
    </div>
    <!-- â–² ã‚­ãƒ£ãƒ©é¸æŠ -->

    <section class="card" id="mainCard" style="margin-top:12px;">
      <div class="log" id="log"></div>
      <div class="choices" id="choices"></div>
      <div class="footer">
        <button id="restart" class="primary">ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="share">çµæœã‚’ã‚³ãƒ”ãƒ¼</button>
      </div>
    </section>
  </main>
</div>

<!-- Pixi + Live2D -->
<script src="https://cdn.jsdelivr.net/npm/pixi.js@7.x/dist/pixi.min.js"></script>
<!-- Cubism Coreï¼ˆã§ãã‚Œã°ãƒ­ãƒ¼ã‚«ãƒ«ã«ç½®ãã€‚GitHub Pagesã§å®‰å®šï¼‰ -->
<script src="./assets/live2d/live2dcubismcore.min.js"></script>
<!-- Cubism4å°‚ç”¨ãƒãƒ³ãƒ‰ãƒ« -->
<script src="https://cdn.jsdelivr.net/npm/pixi-live2d-display/dist/cubism4.min.js"></script>
  
<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const GOAL = 8;
  const BOSS_FLOORS = new Set([4, 8]);
  const MAX_TREASURE = 2; // å®ç®±ã¯æœ€å¤§2å›ã¾ã§
  const MAX_RELICS   = 7; // ãƒ¬ãƒªãƒƒã‚¯æ‰€æŒä¸Šé™ã¯7å€‹ã¾ã§
  // --- ã‚­ãƒ£ãƒ©æ¼”å‡ºç”¨ ---
  const playerWrap = $("playerWrap");
  const enemyWrap  = $("enemyWrap");
  const enemyNameEl = $("enemyName");

  // --- ãƒ€ãƒ¡ãƒ¼ã‚¸æ¼”å‡ºç”¨ ---
  const floatLayer = $("floatLayer");

    // ===== Live2D Controller =====
  // â€» model3.json ã¯ã€ŒMotions/Expressionsã‚’è¿½è¨˜ã—ãŸç‰ˆã€ã‚’æŒ‡ã™
  const L2D = (() => {
    const MODEL_PATH = "./assets/live2d/huohuo/huohuo.model3.json"; // â†ã‚ãªãŸã®é…ç½®ã«åˆã‚ã›ã¦å¤‰æ›´
    let app = null;
    let fitFn = null;
    let model = null;
    let current = { motion:"Idle", exp:null };

    async function init(){
      const wrap = document.getElementById("live2dWrap");
      if(!wrap) return;
      // ã™ã§ã«canvasãŒã‚ã‚‹å ´åˆã¯å†åˆæœŸåŒ–ã—ãªã„
      if(wrap.querySelector("canvas")) return;
      try{
        PIXI.settings.PREFER_ENV = PIXI.ENV.WEBGL; // WebGL2ã˜ã‚ƒãªãWebGL1å¯„ã‚Šã«
        app = new PIXI.Application({
          resizeTo: wrap,
          backgroundAlpha: 0,
          antialias: false,                  // ã‚¹ãƒãƒ›ã§å®‰å®š
          autoDensity: true,
          resolution: Math.min(window.devicePixelRatio || 1, 2), // ä¸Šã’ã™ããªã„
          powerPreference: "high-performance",
        });
        wrap.appendChild(app.view);
        // âœ… æç”»ç¢ºèªç”¨ï¼ˆå·¦ä¸Šã«ç·‘ã®å››è§’ãŒå‡ºã‚Œã°PIXIã¯æã‘ã¦ã‚‹ï¼‰
        const g = new PIXI.Graphics();
        g.beginFill(0x00ff00).drawRect(10, 10, 40, 40).endFill();
        app.stage.addChild(g);

        // âœ… ã“ã“ãŒã€ŒPIXI.live2dã‹ã‚‰å–ã‚‹ã€
        const live2dNS = PIXI.live2d;
        if(!live2dNS || !live2dNS.Live2DModel){
          console.warn("[L2D] PIXI.live2d.Live2DModel is not available. Check script order / cubism4 + core.");
          return;
        }
        const { Live2DModel } = live2dNS; // â† å–ã‚Šå‡ºã—
        model = await Live2DModel.from(MODEL_PATH);
        console.log("[L2D] model loaded:", model);

        model.anchor.set(0.5, 1.0);
        app.stage.addChild(model);

        // âœ… ã¨ã«ã‹ãç”»é¢ã«å‡ºã™ï¼ˆå›ºå®šå€¤ï¼‰
        model.x = app.renderer.width / 2;
        model.y = app.renderer.height;
        model.scale.set(0.4);
        model.alpha = 1;
        model.visible = true;

        // âœ… 1ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã« bounds ã‚’ä½¿ã£ã¦ãƒ•ã‚£ãƒƒãƒˆï¼ˆé«˜ã•å–å¾—ãŒå®‰å®šã™ã‚‹ï¼‰
        requestAnimationFrame(() => {
          const b = model.getBounds();
          const targetH = app.renderer.height * 0.95;
          const s = targetH / (b.height || 1);
          model.scale.set(s);
          model.x = app.renderer.width * 0.35;
          model.y = app.renderer.height * 1.02;
        });

      //   function fit(){
      //     fitFn = fit;
      //     const w = app.renderer.width;
      //     const h = app.renderer.height;

      //     model.anchor.set(0.5, 1);
      //     model.x = w * 0.35;   // å·¦å¯„ã›ï¼ˆå¥½ã¿ã§0.3ã€œ0.45ï¼‰
      //     model.y = h * 1.02;

      //     // é«˜ã•ã®ä½•å‰²ã«åã‚ã‚‹ã‹ï¼ˆ0.95ã¨ã‹ï¼‰
      //     const targetH = h * 0.95;
      //     const s = targetH / model.height;
      //     model.scale.set(s);
      //   }
      //   fit();

      // // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
      // window.addEventListener("resize", ()=> setTimeout(fit, 50));

        // åˆæœŸãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³
        motion("Idle", 0);
      }catch(e){
        console.warn("[L2D] init failed:", e);
      }
    }

    function resize(){
      const wrap = document.getElementById("live2dWrap");
      if(!app || !wrap) return;

      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      if(w <= 0 || h <= 0) return;

      app.renderer.resize(w, h);

      // å¿µã®ãŸã‚canvasã‚‚100%ã«å¯„ã›ã‚‹ï¼ˆç’°å¢ƒå·®å¯¾ç­–ï¼‰
      app.view.style.width  = "100%";
      app.view.style.height = "100%";

      if(fitFn) fitFn();
    }

    function motion(group, index=0){
      if(!model) return;
      try{
        current.motion = group;
        model.motion(group, index);
      }catch(e){
        console.warn("[L2D] motion failed:", group, e);
      }
    }

    function expression(name){
      if(!model) return;
      try{
        current.exp = name;
        model.expression(name);
      }catch(e){
        console.warn("[L2D] expression failed:", name, e);
      }
    }

    // è¡Œå‹•ã‚¿ã‚¤ãƒ— â†’ ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³/è¡¨æƒ…ï¼ˆå¥½ã¿ã§èª¿æ•´ï¼‰
    function onAction(type){
      switch(type){
        case "attack": motion("Attack", 0); break;
        case "strong": motion("Attack", 0); expression("angry"); break;
        case "guard":  motion("Skill", 0); break;
        case "dodge":  motion("Skill", 0); break;
        case "heal":   motion("Skill", 0); expression("baozhen"); break;
        case "cleanse":motion("Skill", 0); expression("white_eyes"); break;
        case "hit":    motion("Damage", 0); break;
        case "win":    motion("Win", 0); break;
        case "lose":   motion("Lose", 0); break;
        default:       motion("Idle", 0); break;
      }

      // ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã«Idleã¸æˆ»ã™ï¼ˆçŸ­ã‚ï¼‰
      if(["attack","strong","guard","dodge","heal","cleanse","hit"].includes(type)){
        setTimeout(()=> motion("Idle", 0), 900);
      }
    }

    return { init, resize, onAction, motion, expression };
  })();
  
  function spawnFloatText(targetEl, text, kind="dmg", opts={}){
    if(!floatLayer || !targetEl) return;
  
    const layerRect = floatLayer.getBoundingClientRect();
    const rect = targetEl.getBoundingClientRect();
  
    // targetEl ã®ä¸­å¤®ä¸Šã‚ãŸã‚Šã«å‡ºã™
    const x = (rect.left + rect.right)/2 - layerRect.left;
    const y = (rect.top + rect.bottom)/2 - layerRect.top - (opts.yOffset ?? 20);
  
    const el = document.createElement("div");
    el.className = `floatText ${kind} ${opts.big ? "big" : ""}`;
    el.textContent = text;
  
    // ãƒ©ãƒ³ãƒ€ãƒ ã«å°‘ã—å·¦å³ã¸ãƒ–ãƒ¬ï¼ˆæ°—æŒã¡è‰¯ããªã‚‹ï¼‰
    const jitterX = (Math.random()*14 - 7);
    el.style.left = (x + jitterX) + "px";
    el.style.top  = y + "px";
  
    floatLayer.appendChild(el);
    el.addEventListener("animationend", ()=> el.remove());
  }
  
  // ===== Audio =====
  const AUDIO = {
    enabled: false,
    bgm: new Audio("./assets/bgm.mp3"),
    se: {
      attack: new Audio("./assets/se_attack.mp3"),
      guard:  new Audio("./assets/se_guard.mp3"),
      heal:   new Audio("./assets/se_heal.mp3"),
      win:    new Audio("./assets/se_win.mp3"),
      lose:   new Audio("./assets/se_lose.mp3"),
      boss:   new Audio("./assets/se_boss.mp3"),
      relic:  new Audio("./assets/se_relic.mp3"),
    }
  };
  
  // BGMè¨­å®š
  AUDIO.bgm.loop = true;
  AUDIO.bgm.volume = 0.45;
  
  // SEéŸ³é‡ï¼ˆå¥½ã¿ã§ï¼‰
  Object.values(AUDIO.se).forEach(a => a.volume = 0.7);
  
  // iOS/Chromeå¯¾ç­–ï¼šæœ€åˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œã§éŸ³ã‚’æœ‰åŠ¹åŒ–
  function enableAudioOnce(){
    if (AUDIO.enabled) return;
    AUDIO.enabled = true;
  
    // ç„¡éŸ³å†ç”Ÿã§ã‚¢ãƒ³ãƒ­ãƒƒã‚¯ï¼ˆå¤±æ•—ã—ã¦ã‚‚OKï¼‰
    Promise.resolve()
      .then(() => AUDIO.bgm.play())
      .then(() => AUDIO.bgm.pause())
      .catch(()=>{});
  }
  
  function playSE(key){
    if(!AUDIO.enabled) return;
    const a = AUDIO.se[key];
    if(!a) return;
    a.currentTime = 0;
    a.play().catch(()=>{});
  }
  
  function playBGM(){
    if(!AUDIO.enabled) return;
    AUDIO.bgm.play().catch(()=>{});
  }
  
  function stopBGM(){
    AUDIO.bgm.pause();
    AUDIO.bgm.currentTime = 0;
  }
  
  // --- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å€™è£œ ---
  const PLAYERS = [
    { id:"p1", name:"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1", src:"./assets/player.png" },
    { id:"p2", name:"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2", src:"./assets/player2.png" },
    // âœ… è¿½åŠ ï¼šLive2Dã‚­ãƒ£ãƒ©
    { id:"p3", name:"ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼3ï¼ˆLive2Dï¼‰", src:"./assets/player.png", live2d:true },
  ];

  function showPlayerPick(){
    S.mode = "pick";
    ui();
  
    $("pickCard").style.display = "block";
    $("mainCard").style.display = "none";   // âœ… ä¸‹ã‚’æ¶ˆã™
  
    const wrap = $("pickChoices");
    wrap.innerHTML = "";
  
    PLAYERS.forEach(p=>{
      const b = document.createElement("button");
      b.className = "primary";
      b.innerHTML = `
        <div class="pickRow">
          <div class="pickThumb"><img src="${p.src}" alt=""></div>
          <div>
            <b>${p.name}</b><br>
            <span class="muted">ã“ã®ã‚­ãƒ£ãƒ©ã§å†’é™ºã™ã‚‹</span>
          </div>
        </div>
      `;
      b.addEventListener("click", async ()=>{ // â† async ã‚’è¿½åŠ 
        $("pickCard").style.display = "none";
        $("mainCard").style.display = "block"; // âœ… ä¸‹ã‚’æˆ»ã™
        setPlayerById(p.id);

        // âœ… Live2Dã‚’ã“ã“ã§èµ·å‹•ï¼ˆ1å›ã ã‘ï¼‰
        //await L2D.init();
        
        enableAudioOnce(); // âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œå†…ã§ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
        playBGM();         // âœ… ã“ã“ã§BGMé–‹å§‹ï¼ˆä»¥é™ãšã£ã¨æµã‚Œã‚‹ï¼‰
        screenChooseRoom();
      });
      wrap.appendChild(b);
    });
  }

  async function setPlayerById(id){
    const p = PLAYERS.find(x=>x.id===id) || PLAYERS[0];
    S.playerId = p.id;
    S.playerSrc = p.src;

    const img = $("playerImg");

    // âœ… p3(Live2D)ãªã‚‰ png ã‚’éš ã—ã¦ Live2D ã‚’è¡¨ç¤º
    if(p.live2d){
      img.style.visibility = "hidden";

      // Live2DãŒæœªåˆæœŸåŒ–ãªã‚‰åˆæœŸåŒ–
      if(!window.__L2D_READY){
        await L2D.init();
        window.__L2D_READY = true;
      }

      // é¸æŠç”»é¢ã§ã‚‚ç¢ºèªã—ãŸã„ãªã‚‰è¡¨ç¤ºï¼ˆæˆ¦é—˜ã ã‘ã«ã—ãŸã„ãªã‚‰ hidden ã«ã—ã¦OKï¼‰
      document.getElementById("live2dWrap").classList.remove("hidden");
      // è¿½åŠ ï¼š2ãƒ•ãƒ¬ãƒ¼ãƒ å¾…ã£ã¦ã‹ã‚‰å¼·åˆ¶ãƒªã‚µã‚¤ã‚ºï¼ˆç¢ºå®Ÿï¼‰
      requestAnimationFrame(() => requestAnimationFrame(() => L2D.resize()));
    }else{
      // âœ… p1/p2ã¯é€šå¸¸ç”»åƒè¡¨ç¤º
      img.style.visibility = "visible";
      img.src = p.src;

      // Live2Dã¯éš ã™ï¼ˆæ®‹ã£ã¦ãŸã‚‰é‚ªé­”ãªã®ã§ï¼‰
      const w = document.getElementById("live2dWrap");
      if(w) w.classList.add("hidden");
    }

    // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å·®åˆ†
    if(p.id==="p1"){
      S.maxhp = 24; S.hp = 24;
    }else if(p.id==="p2"){
      S.gold += 15;
    }else if(p.id==="p3"){
      // Live2Dã‚­ãƒ£ãƒ©ç”¨ã®ç‰¹å…¸ï¼ˆå¥½ãã«èª¿æ•´ï¼‰
      S.maxhp = 22; S.hp = 22;
    }

    ui();
  }
  
  // ã‚¢ãƒ‹ãƒ¡ã‚’ç¢ºå®Ÿã«å†ç”Ÿã™ã‚‹ãŸã‚ã€classã‚’ä»˜ã‘ç›´ã™
  function playAnim(el, cls, ms=350){
    el.classList.remove(cls);
    void el.offsetWidth; // reflow
    el.classList.add(cls);
    setTimeout(()=>el.classList.remove(cls), ms);
  }
  
  function setEnemyVisible(visible){
    if(visible) enemyWrap.classList.remove("hidden");
    else enemyWrap.classList.add("hidden");
  }

  function setIdle(on){
    playerWrap.classList.toggle("idle", on);
    enemyWrap.classList.toggle("idle", on && !!S.enemy);
  }

  function gainFocus(n){
    S.focus = clamp(S.focus + n, 0, S.focusMax);
  }
  function spendFocus(n){
    if(S.focus < n) return false;
    S.focus -= n;
    return true;
  }
  function tickCooldowns(){
    if(S.breakCD > 0) S.breakCD--;
  }
  function tickCooldownsSafe(){
    if(S.justUsedBreak){
      S.justUsedBreak = false; // ã“ã®ã‚¿ãƒ¼ãƒ³ã ã‘æ¸›ã‚‰ã•ãªã„
      return;
    }
    tickCooldowns();
  }
  
  // -------------- ä¾¿åˆ©é–¢æ•° --------------
  const r = (min,max)=>Math.floor(Math.random()*(max-min+1))+min;
  const clamp = (v,a,b)=>Math.max(a, Math.min(b, v));
  const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const chance = (p)=>Math.random()<p;

  const isBossFloor = (floor)=>BOSS_FLOORS.has(floor);


  // -------------- çŠ¶æ…‹ç•°å¸¸ --------------
  const formatStatuses = (st)=>{
    const parts = [];
    if(st.poison>0) parts.push(`æ¯’${st.poison}`);
    if(st.burn>0) parts.push(`ç«å‚·${st.burn}`);
    if(st.weaken>0) parts.push(`å¼±ä½“${st.weaken}`);
    if(st.vulnerable>0) parts.push(`è„†å¼±${st.vulnerable}`);
    if(st.stun>0) parts.push(`ã‚¹ã‚¿ãƒ³${st.stun}`);
    return parts.length ? parts.join(" / ") : "ãªã—";
  };

  function addStatus(target, kind, turns, optDmg=0){
    // ãƒ¬ãƒªãƒƒã‚¯è£œæ­£ï¼ˆå‰ç« ã®ã‚„ã¤ï¼‰
    const pack = applyRelicsHook("onApplyStatus", { target, kind, turns, dmg: optDmg });
    if(pack){ target=pack.target; kind=pack.kind; turns=pack.turns; optDmg=pack.dmg; }
  
    // âœ… ãƒœã‚¹è€æ€§ï¼ˆæ•µã«ä»˜ä¸ã™ã‚‹å ´åˆï¼‰
    if(target==="enemy" && S.enemy){
      if(enemyImmune(kind)) return; // ç„¡åŠ¹
      const mul = enemyTraitMul(kind, "statusMul");
      turns = Math.max(0, Math.round(turns * mul));
      if(turns<=0) return;
    }
  
    const st = target === "enemy" ? S.eStatus : S.pStatus;
    st[kind] = Math.max(st[kind]||0, turns);
    if(kind==="poison" && optDmg) st.poisonDmg = optDmg;
    if(kind==="burn" && optDmg)   st.burnDmg   = optDmg;
  }

  function givePotion(type){
    // 1å€‹ã—ã‹æŒã¦ãªã„ï¼šã™ã§ã«ã‚ã‚‹ãªã‚‰ä¸Šæ›¸ãã—ãªã„ï¼ˆä¸Šæ›¸ãã—ãŸã„ãªã‚‰ã“ã“ã‚’å¤‰æ›´ï¼‰
    if(S.potion) return false;
  
    if(type === "heal"){
      S.potion = { type:"heal", name:"å›å¾©ãƒãƒ¼ã‚·ãƒ§ãƒ³" };
      return true;
    }
    if(type === "cleanse"){
      S.potion = { type:"cleanse", name:"æµ„åŒ–ãƒãƒ¼ã‚·ãƒ§ãƒ³" };
      return true;
    }
    return false;
  }
  
  function usePotion(){
    if(!S.potion) return { ok:false, msg:"ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ãªã„" };
  
    if(S.potion.type === "heal"){
      let h = 10;
      h = applyRelicsHook("onHeal", h);
      S.hp = clamp(S.hp + h, 0, S.maxhp);
      const msg = `ğŸ§ª å›å¾©ãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ HPã‚’ <b>${h}</b> å›å¾©ã€‚`;
      S.potion = null;
      return { ok:true, msg };
    }
  
    if(S.potion.type === "cleanse"){
      // doCleanse ã¨åŒç­‰ï¼ˆã‚¹ã‚¿ãƒ³ã¯åŸºæœ¬è§£é™¤ã—ãªã„ï¼‰
      S.pStatus.poison = 0; S.pStatus.poisonDmg = 0;
      S.pStatus.burn   = 0; S.pStatus.burnDmg   = 0;
      S.pStatus.weaken = 0;
      S.pStatus.vulnerable = 0;
   
      const msg = `ğŸ§ª æµ„åŒ–ãƒãƒ¼ã‚·ãƒ§ãƒ³ï¼ çŠ¶æ…‹ç•°å¸¸ã‚’è§£é™¤ã—ãŸã€‚<br><small>åŠ è­·ï¼šæ¬¡ã®è¢«ãƒ€ãƒ¡ -<b>${S.healWard}</b></small>`;
      S.potion = null;
      return { ok:true, msg };
    }
  
    return { ok:false, msg:"ã“ã®ãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ä½¿ãˆãªã„" };
  }
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ“ä½œæ¨©ãŒæˆ»ã‚‹ç›´å‰ã«å‘¼ã¶ï¼ˆæ¯’/ç«å‚·ãªã©ã®DOTã€ã‚¹ã‚¿ãƒ³ã®ã‚¹ã‚­ãƒƒãƒ—ï¼‰
  function presentPlayerChoices(){
    const prepend = [];

    if(S.pStatus.poison>0){
      const d = S.pStatus.poisonDmg || (2 + Math.floor(S.floor/3));
      S.hp = clamp(S.hp - d, 0, S.maxhp);
      S.pStatus.poison--;
      prepend.push(`â˜ ï¸ æ¯’ã§ <b>${d}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸`);
      spawnFloatText(playerWrap, `-${d}`, "dot");
    }
    if(S.pStatus.burn>0){
      const d = S.pStatus.burnDmg || (2 + Math.floor(S.floor/4));
      S.hp = clamp(S.hp - d, 0, S.maxhp);
      S.pStatus.burn--;
      prepend.push(`ğŸ”¥ ç«å‚·ã§ <b>${d}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸`);
      spawnFloatText(playerWrap, `-${d}`, "dot");
    }

    if(prepend.length){
      $("log").innerHTML = prepend.join("<br>") + "<br>" + $("log").innerHTML;
    }

    ui();
    if(S.hp <= 0){
      stopBGM();
      playSE("lose");
      S.mode = "gameover";
      ui();
      log(`<span class="pill bad">æ•—åŒ—</span>çŠ¶æ…‹ç•°å¸¸ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã§å€’ã‚ŒãŸâ€¦<br><small>åˆ°é”ï¼šéšå±¤${S.floor}/${GOAL} / å‹åˆ©æ•°:${S.wins} / æ‰‹æ•°:${S.turns}</small>`);
      setChoices([]);
      return;
    }

    if(S.pStatus.stun>0){
      S.pStatus.stun--;
      ui();
      $("log").innerHTML = `ğŸ˜µ ã‚¹ã‚¿ãƒ³ã§å‹•ã‘ãªã„ï¼<br>` + $("log").innerHTML;
      setChoices([]); // ã‚¯ãƒªãƒƒã‚¯ä¸èƒ½ã«ã—ã¦å³æ•µã‚¿ãƒ¼ãƒ³ã¸
      S.last = "ğŸ˜µ ã‚¹ã‚¿ãƒ³ã§å‹•ã‘ãªã„ï¼";
      return enemyTurn();
    }

    // âœ… ã“ã“ãŒãƒã‚¤ãƒ³ãƒˆï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é¸æŠè‚¢ã‚’å‡ºã™
    setChoices(makeCombatChoices());
    setIdle(true);
  }

  // -------------- ãƒ¬ãƒªãƒƒã‚¯å®šç¾© --------------
  const RELICS = [
    { id:"spike", name:"ãƒˆã‚²ã®æŒ‡è¼ª", desc:"æ”»æ’ƒ+1ï¼ˆæ¯å›ï¼‰", onAtk:(s, dmg)=>dmg+1 },
    { id:"bandage", name:"åŒ…å¸¯", desc:"æˆ¦é—˜å‹åˆ©ã§HP+2", onWin:(s)=>{ s.hp = clamp(s.hp+2, 0, s.maxhp); } },
    { id:"coin", name:"å¹¸é‹ã®ã‚³ã‚¤ãƒ³", desc:"å®ç®±/ã‚¤ãƒ™ãƒ³ãƒˆã§+8ã‚³ã‚¤ãƒ³", onGainGold:(s, amt, src)=> (src!=="combat") ? amt+8 : amt },
    { id:"shield", name:"å¤ã„ç›¾", desc:"é˜²å¾¡ã‚’å¾—ã‚‹é‡+2", onBlock:(s, b)=>b+2 },
    { id:"blood", name:"è¡€ã®å¥‘ç´„", desc:"å›å¾©é‡+2ã€æœ€å¤§HP-2", onPick:(s)=>{ s.maxhp=Math.max(8, s.maxhp-2); s.hp=clamp(s.hp,0,s.maxhp); }, onHeal:(s, h)=>h+2 },
    { id:"rage", name:"æ€’ã‚Šã®ä»®é¢", desc:"HP50%ä»¥ä¸‹ã®æ™‚ æ”»æ’ƒ+3", onAtk:(s, dmg)=> (s.hp <= Math.floor(s.maxhp/2)) ? dmg+3 : dmg },
    { id:"mender", name:"å°ã•ãªä¿®ç†å…·", desc:"ä¼‘æ†©ã§ã•ã‚‰ã«HP+3", onRest:(s, heal)=>heal+3 },
    { id:"gambler", name:"ã‚®ãƒ£ãƒ³ãƒ–ãƒ©ãƒ¼", desc:"è³­ã‘æˆåŠŸç‡+15%", onGambleChance:(s, p)=>Math.min(0.95, p+0.15) },
    { id:"thief", name:"ç›—è³Šã®æ‰‹è¢‹", desc:"æˆ¦é—˜å‹åˆ©ã‚³ã‚¤ãƒ³+5", onGainGold:(s, amt, src)=> (src==="combat") ? amt+5 : amt },
    { id:"toxic_charm", name:"æ¯’ã®ãŠå®ˆã‚Š", desc:"æ¯’ã®æŒç¶š+1", 
      onApplyStatus:(s, pack)=>{
        if(pack.kind==="poison") pack.turns += 1;
        return pack;
      }
    },
    { id:"blazing_oil", name:"ç¼ç†±ã®æ²¹", desc:"ç«å‚·ãƒ€ãƒ¡ãƒ¼ã‚¸+1",
      onDotDamage:(s, pack)=>{
        if(pack.kind==="burn") pack.dmg += 1;
        return pack;
      }
    },
    { id:"antidote", name:"è§£æ¯’ã®è­·ç¬¦", desc:"æ¯’ã‚’å—ã‘ã‚‹ã¨50%ã§ç„¡åŠ¹åŒ–",
      onApplyStatus:(s, pack)=>{
        if(pack.target==="player" && pack.kind==="poison" && Math.random()<0.5){
          pack.turns = 0; pack.dmg = 0;
        }
        return pack;
      }
    },
  ];

  // -------------- çŠ¶æ…‹ --------------
  const S = {
    floor: 1,
    maxhp: 20,
    hp: 20,
    block: 0,
    gold: 0,
    wins: 0,
    relics: [],
    mode: "chooseRoom",
    enemy: null,
    enemyIntent: 0,
    turns: 0,
    last: "",
    tempStartBlock: 0,
    over: false,
    won: false,
    playerId: null,
    playerSrc: "./assets/player.png",
    lastBossFloorCleared: 0,
    treasureCount: 0,
    bossPrepRestUsed: false,
    bossPrepShopUsed: false,
    bossPrepEventUsed: false,
    bossPrepInitFloor: 0,  // â†è¿½åŠ ï¼šã“ã®éšã®bossPrepã‚’åˆæœŸåŒ–ã—ãŸã‹
    potion: null, // { type:"heal"|"cleanse", name:"å›å¾©ãƒãƒ¼ã‚·ãƒ§ãƒ³"|"æµ„åŒ–ãƒãƒ¼ã‚·ãƒ§ãƒ³" }
    // --- LV ---
    level: 1,
    xp: 0,
    xpNeed: 3,
    // --- æˆ¦ç•¥è¦ç´  ---
    focus: 0,
    focusMax: 6,
    breakCD: 0,        // ãƒ–ãƒ¬ã‚¤ã‚¯ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰å˜ä½ï¼‰
    breakStun: 0,      // ãƒ–ãƒ¬ã‚¤ã‚¯ã§æ•µãŒã²ã‚‹ã‚€ã‚¿ãƒ¼ãƒ³æ•°ï¼ˆ1ãªã‚‰æ¬¡ã®æ•µè¡Œå‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    enemyWeaken: 0,    // æ¬¡ã®æ•µæ”»æ’ƒ -â—‹ï¼ˆå¼·æ”»æ’ƒãªã©ã®å°ã•ãªå‰¯ä½œç”¨ã§ä½¿ã†ï¼‰
    evadeRate: 0,      // æ¬¡ã®è¢«ãƒ€ãƒ¡ã‚’å‰²åˆè»½æ¸›ï¼ˆä¾‹:0.6=60%è»½æ¸›ï¼‰
    healWard: 0,       // å›å¾©ã—ãŸã‚‰ä»˜ãã€Œæ¬¡ã®è¢«ãƒ€ãƒ¡-â—‹ã€ï¼ˆå›ºå®šè»½æ¸›ï¼‰
    enemyIntentType: "normal", // "normal" | "charge" | "heavy"
    enemyNextHeavy: 0, // æºœã‚ã®æ™‚ã«äºˆå‘Šã™ã‚‹å¼·æ”»æ’ƒå€¤
    justUsedBreak: false,
    bossPrepDone: 0,  // ãã®éšã®ãƒœã‚¹å‰æº–å‚™ã‚’æ¸ˆã¾ã›ãŸã‹ï¼ˆ4 or 8 ã‚’å…¥ã‚Œã‚‹ï¼‰
    inBossPrep: false, // ä»ŠãŒãƒœã‚¹å‰æº–å‚™ã®å‡¦ç†ä¸­ã‹
    nonCombatUsed: false,
    // --- çŠ¶æ…‹ç•°å¸¸ ---
    pStatus: { poison:0, poisonDmg:0, burn:0, burnDmg:0, weaken:0, vulnerable:0, stun:0 },
    eStatus: { poison:0, poisonDmg:0, burn:0, burnDmg:0, weaken:0, vulnerable:0, stun:0 },
    enemyIntentMeta: null,
    bossPicked: {},
  };

  // -------------- åŠ¹æœé©ç”¨ --------------
  function applyRelicsHook(hookName, ...args){
    let out = args[0];
    for(const id of S.relics){
      const rel = RELICS.find(x=>x.id===id);
      const fn = rel && rel[hookName];
      if(typeof fn === "function"){
        const res = fn(S, out, ...args.slice(1));
        if(res !== undefined) out = res;
      }
    }
    return out;
  }

  function intentText(){
    if(!S.enemy) return "-";
    if(S.enemyIntentMeta && S.enemyIntentMeta.intentText) return S.enemyIntentMeta.intentText;
    if(S.enemyIntentType === "charge") return `æºœã‚ï¼ˆæ¬¡:${S.enemyNextHeavy}ï¼‰`;
    if(S.enemyIntentType === "heavy")  return `å¼·æ”»æ’ƒ:${S.enemyIntent}`;
    if(S.enemyIntentType === "recoil") return `åå‹•ï¼ˆéš™ï¼‰`;
    if(S.enemyIntentType === "skill")  return `ã‚¹ã‚­ãƒ«`;
    return `${S.enemyIntent}`;
  }
  
  // -------------- UI --------------
  function ui(){
    $("focus").textContent = S.focus;
    $("focusMax").textContent = S.focusMax;
    $("breakCD").textContent = S.breakCD;
    if($("pstatus")) $("pstatus").textContent = formatStatuses(S.pStatus);
    $("hp").textContent = S.hp;
    $("maxhp").textContent = S.maxhp;
    $("block").textContent = S.block;
    $("gold").textContent = S.gold;
    $("floor").textContent = S.floor;
    $("goal").textContent = GOAL;
    $("wins").textContent = S.wins;
    
    $("hpbar").style.width = `${(S.hp/S.maxhp)*100}%`;

    if($("potion")) $("potion").textContent = S.potion ? S.potion.name : "ãªã—";
    
    if(S.enemy){
      $("ehp").textContent = S.enemy.hp;
      $("emaxhp").textContent = S.enemy.maxhp;
      $("ehpbar").style.width = `${(S.enemy.hp/S.enemy.maxhp)*100}%`;
      // äºˆå®šæ”»æ’ƒã®è¡¨ç¤ºï¼ˆæºœã‚/å¼·æ”»æ’ƒã‚’è¦‹ã›ã‚‹ï¼‰
      if(S.enemyIntentType === "charge"){
        $("eintent").textContent = `æºœã‚ï¼ˆæ¬¡:${S.enemyNextHeavy}ï¼‰`;
      }else if(S.enemyIntentType === "heavy"){
        $("eintent").textContent = `å¼·æ”»æ’ƒ:${S.enemyIntent}`;
      }else if(S.enemyIntentType === "recoil"){
        $("eintent").textContent = `åå‹•ï¼ˆéš™ï¼‰`;
      }else{
        $("eintent").textContent = S.enemyIntent;
      }
      if(S.enemyIntentMeta && S.enemyIntentMeta.intentText){
        $("eintent").textContent = S.enemyIntentMeta.intentText;
      }
      if($("estatus")) $("estatus").textContent = formatStatuses(S.eStatus);
      enemyNameEl.textContent = S.enemy.name || "";
      const eimg = $("enemyImg");
      if(eimg) eimg.src = S.enemy.src || "./assets/enemy.png";
      setEnemyVisible(true);
      // ãƒœã‚¹ãªã‚‰è¦‹ãŸç›®å¼·åŒ–
      enemyWrap.classList.toggle("boss", !!S.enemy.boss);
    }else{
      $("ehp").textContent = "-";
      $("emaxhp").textContent = "-";
      $("ehpbar").style.width = "0%";
      $("eintent").textContent = "-";
      if($("estatus")) $("estatus").textContent = "ãªã—";
      enemyNameEl.textContent = "";
      const eimg = $("enemyImg");
      if(eimg) eimg.src = "./assets/enemy.png";
      setEnemyVisible(false);
      enemyWrap.classList.remove("boss");

      setIdle(false);
    }

    // ãƒ¬ãƒªãƒƒã‚¯è¡¨ç¤º
    const wrap = $("relics");
    wrap.innerHTML = "";
    if(S.relics.length===0){
      const t = document.createElement("div");
      t.className = "tag";
      t.textContent = "ãƒ¬ãƒªãƒƒã‚¯ï¼šãªã—";
      wrap.appendChild(t);
    }else{
      for(const id of S.relics){
        const rel = RELICS.find(x=>x.id===id);
        const t = document.createElement("div");
        t.className = "tag";
        t.textContent = `${rel.name}`;
        wrap.appendChild(t);
      }
    }

    // âœ… ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã¯ã€Œè² ã‘ãŸæ™‚ã ã‘ã€è¡¨ç¤º
    $("restart").style.display = (S.mode === "gameover") ? "inline-block" : "none";

    if(S.mode === "pick"){
      setEnemyVisible(false);
    }
  }

  function log(html){ $("log").innerHTML = html; }
  function setChoices(arr){
    const wrap = $("choices");
    wrap.innerHTML = "";
    arr.forEach(c=>{
      const b = document.createElement("button");
      b.className = c.cls || "";
      b.innerHTML = c.label;
      b.disabled = !!c.disabled;
      b.addEventListener("click", c.onClick);
      wrap.appendChild(b);
    });
  }

  // -------------- ãƒ«ãƒ¼ãƒ ç”Ÿæˆ --------------
  const ROOM_TYPES = ["combat","combat","combat","treasure","event","rest","shop"];
  const ROOM_LABEL = {
    combat: { icon:"âš”ï¸", name:"æˆ¦é—˜" },
    treasure:{ icon:"ğŸ§°", name:"å®ç®±" },
    event:  { icon:"â“", name:"ã‚¤ãƒ™ãƒ³ãƒˆ" },
    rest:   { icon:"ğŸ›ï¸", name:"ä¼‘æ†©" },
    shop:   { icon:"ğŸ›’", name:"å•†äºº" },
  };

  function nextRooms(){
    const pool = ROOM_TYPES.slice();
    // å®ç®±ã®å‡ºç¾å›æ•°åˆ¶é™ï¼ˆ2å›å–ã£ãŸã‚‰ä»¥é™ã¯å®ç®±æ‰‰ãŒå‡ºãªã„ï¼‰
    if (S.treasureCount >= MAX_TREASURE) {
      for (let i = pool.length - 1; i >= 0; i--) {
        if (pool[i] === "treasure") pool.splice(i, 1);
      }
    }
    if(S.floor <= 2){
      pool.push("rest","shop");
    }
    if(S.floor >= GOAL-2){
      pool.push("combat","combat");
    }
    const rooms = [];
    while(rooms.length<3){
      const t = pick(pool);
      if(rooms.filter(x=>x===t).length>=2) continue;
      rooms.push(t);
    }
    return rooms;
  }

  // -------------- æ•µ --------------
  function enemyForFloor(f){
    const base = 9 + f*3;
    return {
      name: pick(["ã‚¹ãƒ©ã‚¤ãƒ ","ã‚´ãƒ–ãƒªãƒ³","ã‚³ãƒœãƒ«ãƒˆ","å½±ã®ç£","é§ã®äº¡éœŠ"]),
      maxhp: base,
      hp: base,
      atkMin: 2 + f,
      atkMax: 4 + f*2,
      boss: false,
      // âœ…ã“ã“ã‚’è¿½åŠ ï¼šçŠ¶æ…‹ç•°å¸¸(DOT)å€ç‡ï¼ˆå¼±ç‚¹/è€æ€§ï¼‰
      dotMult: { poison: 1.0, burn: 1.0 },
      // ä¾‹ï¼šè€æ€§ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ã™ã‚‹ãªã‚‰ã“ã“ã§ã„ã˜ã‚‹
    };
  }

  // -------------- å…±é€šé–¢æ•°ï¼šå€ç‡/ç„¡åŠ¹ã®åˆ¤å®š --------------
  function enemyTraitMul(kind, tableName){
    const t = S.enemy?.traits?.[tableName];
    if(!t) return 1;
    return (t[kind] ?? 1);
  }
  function enemyImmune(kind){
    const im = S.enemy?.traits?.immune;
    return !!(im && im[kind]);
  }
  
  // -------------- ãƒœã‚¹ï¼ˆè¤‡æ•°ï¼‹æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ --------------
  const BOSSES = [
    {
      id: "beast",
      name4: "é–€ç•ªã®å·¨ç£",
      name8: "æ·±å±¤ã®ç‹",
      src4: "./assets/boss_knight.png",
      src8: "./assets/boss_king.png",
      build(f){
        // æ—¢å­˜ã®ã€Œæºœã‚â†’å¼·æ”»æ’ƒâ†’åå‹•ã€ç³»
        const base = 18 + f*5;
        const atkMin = 6 + f;
        const atkMax = 10 + f*2;
        const e = {
          name: (f===8) ? this.name8 : this.name4,
          src:  (f===8) ? this.src8  : this.src4,
          maxhp: base,
          hp: base,
          atkMin, atkMax,
          boss: true,
          // âœ…ã“ã“ã‚’è¿½åŠ ï¼šæ¯’ã«ã‚‚ç«å‚·ã‚‚æ™®é€š
          dotMult: { poison: 1.0, burn: 1.0 },
          _charged:false,
          _heavyValue:0,
          _recoil:false,
          rollIntent(s, opts={}){
            const forceNormal = !!opts.forceNormal;
            s.enemyIntentMeta = null;
            s.enemyIntentType = "normal";
            s.enemyNextHeavy = 0;

            if(this._recoil){
              s.enemyIntentType = "recoil";
              s.enemyIntent = 0;
              this._recoil = false;
              return;
            }
            if(forceNormal){
              this._charged = false;
              this._heavyValue = 0;
              s.enemyIntent = r(this.atkMin, this.atkMax);
              return;
            }
            if(this._charged){
              s.enemyIntentType = "heavy";
              s.enemyIntent = this._heavyValue || r(this.atkMin, this.atkMax);
              this._charged = false;
              this._heavyValue = 0;
              // heavy ã®å‰¯ä½œç”¨ï¼šã¨ãã©ãè„†å¼±ã‚’ä»˜ä¸
              if(Math.random() < 0.35){
                s.enemyIntentMeta = { apply: { vulnerable: { turns: 2 } }, intentText: `å¼·æ”»æ’ƒ:${s.enemyIntent}ï¼ˆè„†å¼±ï¼‰` };
              }
              return;
            }
            // ãŸã¾ã«æºœã‚
            if(Math.random() < 0.30){
              s.enemyIntentType = "charge";
              const heavy = r(this.atkMin + 4, this.atkMax + 8);
              s.enemyNextHeavy = heavy;
              this._charged = true;
              this._heavyValue = heavy;
              s.enemyIntent = 0;
              return;
            }
            s.enemyIntent = r(this.atkMin, this.atkMax);
          }
        };
        return e;
      }
    },
    {
      id: "venom",
      name4: "æ¯’ã®å¥³ç‹",
      name8: "å¤§æ¯’æ¯ï¼ˆãƒ´ã‚§ãƒãƒ ï¼‰",
      src4: "./assets/boss_hydra.png",
      src8: "./assets/boss_venom2.png",
      build(f){
        const base = 16 + f*5;
        const atkMin = 5 + f;
        const atkMax = 9 + f*2;
        const e = {
          name: (f===8) ? this.name8 : this.name4,
          src:  (f===8) ? this.src8  : this.src4,
          maxhp: base,
          hp: base,
          atkMin, atkMax,
          boss: true,
          // âœ…ã“ã“ã‚’è¿½åŠ ï¼šæ¯’ã«å¼·ã„ãŒç«å‚·ã«å¼±ã„
          dotMult: { poison: 0.5, burn: 1.5 },
          _step: 0,
          _charged:false,
          _heavyValue:0,
          _recoil:false,
          rollIntent(s, opts={}){
            const forceNormal = !!opts.forceNormal;
            s.enemyIntentMeta = null;
            s.enemyIntentType = "normal";
            s.enemyNextHeavy = 0;

            // åå‹•
            if(this._recoil){
              s.enemyIntentType = "recoil";
              s.enemyIntent = 0;
              this._recoil = false;
              return;
            }

            if(forceNormal){
              this._charged = false;
              this._heavyValue = 0;
              s.enemyIntent = r(this.atkMin, this.atkMax);
              return;
            }

            // æºœã‚æ¸ˆã¿ â†’ å¼·æ”»æ’ƒï¼ˆæ¯’ä»˜ä¸ï¼‰
            if(this._charged){
              s.enemyIntentType = "heavy";
              s.enemyIntent = this._heavyValue;
              this._charged = false;
              this._heavyValue = 0;
              s.enemyIntentMeta = {
                apply: { poison: { turns: 3, dmg: 2 + Math.floor(s.floor/3) } },
                intentText: `å¼·æ”»æ’ƒ:${s.enemyIntent}ï¼ˆæ¯’ï¼‰`
              };
              return;
            }

            // ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆå¾ªç’°ï¼‰
            // 0:é€šå¸¸ / 1:æ¯’ç‰™ / 2:ç³¸ï¼ˆã‚¹ã‚¿ãƒ³ï¼‰ / 3:æºœã‚ / 4:é€šå¸¸
            const step = this._step % 5;
            this._step++;

            if(step===1){
              // æ¯’ç‰™
              s.enemyIntent = r(this.atkMin, this.atkMax);
              s.enemyIntentMeta = {
                apply: { poison: { turns: 3, dmg: 2 + Math.floor(s.floor/3) } },
                intentText: `æ¯’æ”»æ’ƒ:${s.enemyIntent}`
              };
              return;
            }
            if(step===2){
              // ç³¸ã§æ‹˜æŸï¼šå°ãƒ€ãƒ¡+ã‚¹ã‚¿ãƒ³
              s.enemyIntent = r(1,3) + Math.floor(s.floor/4);
              s.enemyIntentMeta = {
                apply: { stun: { turns: 1 } },
                intentText: `æ‹˜æŸ:${s.enemyIntent}ï¼ˆã‚¹ã‚¿ãƒ³ï¼‰`
              };
              return;
            }
            if(step===3){
              // æºœã‚ â†’ æ¬¡ã«å¼·æ”»æ’ƒ
              s.enemyIntentType = "charge";
              const heavy = r(this.atkMin + 5, this.atkMax + 9);
              s.enemyNextHeavy = heavy;
              this._charged = true;
              this._heavyValue = heavy;
              s.enemyIntent = 0;
              return;
            }
            // é€šå¸¸
            s.enemyIntent = r(this.atkMin, this.atkMax);
          }
        };
        return e;
      }
    },
    {
      id: "lich",
      name4: "å‘ªè¡“ã®ãƒªãƒƒãƒ",
      name8: "æ·±æ·µã®å¤§ãƒªãƒƒãƒ",
      src4: "./assets/boss_witch.png",
      src8: "./assets/boss_lich2.png",
      build(f){
        const base = 14 + f*6;
        const atkMin = 5 + f;
        const atkMax = 9 + f*2;
        const e = {
          name: (f===8) ? this.name8 : this.name4,
          src:  (f===8) ? this.src8  : this.src4,
          maxhp: base,
          hp: base,
          atkMin, atkMax,
          boss: true,
          // âœ…ã“ã“ã‚’è¿½åŠ ï¼šæ¯’ã«å¼·ãã€ç«å‚·ã¯ç„¡åŠ¹
          dotMult: { poison: 0.5, burn: 0 },
          _step: 0,
          rollIntent(s, opts={}){
            const forceNormal = !!opts.forceNormal;
            s.enemyIntentMeta = null;
            s.enemyIntentType = "normal";
            s.enemyNextHeavy = 0;

            if(forceNormal){
              s.enemyIntent = r(this.atkMin, this.atkMax);
              return;
            }

            const step = this._step % 5;
            this._step++;

            if(step===0){
              // å‘ªã„ï¼šãƒ€ãƒ¡ãªã—ã§å¼±ä½“+è„†å¼±
              s.enemyIntentType = "skill";
              s.enemyIntent = 0;
              s.enemyIntentMeta = {
                apply: { weaken: { turns: 2 }, vulnerable: { turns: 2 } },
                intentText: "å‘ªã„ï¼ˆå¼±ä½“/è„†å¼±ï¼‰",
                noDamage: true
              };
              return;
            }
            if(step===2){
              // å¸åï¼šæ”»æ’ƒï¼‹å›å¾©
              s.enemyIntent = r(this.atkMin, this.atkMax) + 2;
              s.enemyIntentMeta = { drain: 0.5, intentText: `å¸å:${s.enemyIntent}` };
              return;
            }
            if(step===4){
              // ç«çƒï¼šé‡ã‚ï¼‹ç«å‚·
              s.enemyIntentType = "heavy";
              s.enemyIntent = r(this.atkMin+4, this.atkMax+8);
              s.enemyIntentMeta = { apply: { burn: { turns: 2, dmg: 2 + Math.floor(s.floor/4) } }, intentText: `ç«çƒ:${s.enemyIntent}ï¼ˆç«å‚·ï¼‰` };
              return;
            }
            // é­”å¼¾ï¼ˆé€šå¸¸ï¼‰
            s.enemyIntent = r(this.atkMin, this.atkMax);
          }
        };
        return e;
      }
    },
  ];

  function pickBossIdForFloor(f){
    // 4F/8Fã”ã¨ã«1ä½“å›ºå®šï¼ˆåŒã˜éšã§æˆ»ã£ã¦ã‚‚åŒã˜ãƒœã‚¹ï¼‰
    if(S.bossPicked[f]) return S.bossPicked[f];
    const id = pick(BOSSES).id;
    S.bossPicked[f] = id;
    return id;
  }

  function bossEnemyForFloor(f){
    const id = pickBossIdForFloor(f);
    const def = BOSSES.find(b=>b.id===id) || BOSSES[0];
    return def.build(f);
  }

  function rollEnemyIntent(opts = {}){
    const forceNormal = !!opts.forceNormal;

    // åˆæœŸåŒ–
    S.enemyIntentMeta = null;

    // ãƒœã‚¹ã¯å€‹åˆ¥AI
    if(S.enemy && typeof S.enemy.rollIntent === "function"){
      S.enemy.rollIntent(S, { forceNormal });
      return;
    }

    // é€šå¸¸æ•µã¯ãƒ©ãƒ³ãƒ€ãƒ 
    S.enemyIntentType = "normal";
    S.enemyNextHeavy = 0;
    S.enemyIntent = r(S.enemy.atkMin, S.enemy.atkMax);
  }

  // -------------- ç”»é¢ï¼šéƒ¨å±‹é¸æŠ --------------
  function screenChooseRoom(){
    console.log("chooseRoom", { floor: S.floor, lastBossFloorCleared: S.lastBossFloorCleared, mode: S.mode });
    // ãƒœã‚¹éšã«å…¥ã£ãŸã‚‰
    if(isBossFloor(S.floor)){
      // ã‚‚ã—ã€Œå€’ã—ãŸã¯ãšã®éšã«ã¾ã ã„ã‚‹ã€ãªã‚‰ã€æ¬¡ã¸é€²ã‚ã¦å¾©æ—§
      if(S.lastBossFloorCleared === S.floor){
        if(S.floor >= GOAL) return screenVictory();
        S.floor++;
      }else{
        // âœ… ã¾ã æº–å‚™ã—ã¦ãªã„ãªã‚‰æº–å‚™éƒ¨å±‹ã¸
        if(S.bossPrepDone !== S.floor){
          return screenBossPrep();
        }
        // âœ… æº–å‚™æ¸ˆã¿ãªã‚‰ãƒœã‚¹ã¸
        return screenCombatStart(true);
      }
    }

    S.mode = "chooseRoom";
    S.block = 0;
    S.enemy = null;
    ui();

    // éæˆ¦é—˜ç”»é¢ã¯ Live2D ã‚’éš ã—ã¦ png ã‚’è¦‹ã›ã‚‹
    const p = PLAYERS.find(x => x.id === S.playerId);
    if (p && p.live2d) {
      document.getElementById("live2dWrap").classList.remove("hidden");
      document.getElementById("playerImg").style.visibility = "hidden";
    } else {
      document.getElementById("live2dWrap").classList.add("hidden");
      document.getElementById("playerImg").style.visibility = "visible";
    }

    // âœ… éæˆ¦é—˜ã‚’ã“ã®éšã§æ—¢ã«ä½¿ã£ã¦ã„ãŸã‚‰ã€æ‰‰ã‚’æˆ¦é—˜ã ã‘ã«ã™ã‚‹ï¼ˆç„¡é™ä¼‘æ†©/ç„¡é™ã‚¤ãƒ™ãƒ³ãƒˆé˜²æ­¢ï¼‰
    const rooms = S.nonCombatUsed
      ? ["combat","combat","combat"]
      : nextRooms();
    
    log(
      `<span class="pill neu">éšå±¤${S.floor}</span>æ‰‰ãŒ3ã¤ã‚ã‚‹ã€‚ã©ã‚Œã«é€²ã‚€ï¼Ÿ` +
      (S.nonCombatUsed ? `<br><small>â€» ã“ã®éšå±¤ã§ã¯æ—¢ã«éæˆ¦é—˜ã‚’ä½¿ã£ãŸãŸã‚ã€æ¬¡ã¯æˆ¦é—˜ã®ã¿ã€‚</small>` : `<br><small>â€» 4éš/8éšã¯ãƒœã‚¹æˆ¦ï¼ˆç¢ºå®šãƒ¬ãƒªãƒƒã‚¯ï¼‰</small>`)
    );

    setChoices(rooms.map(t=>{
      const info = ROOM_LABEL[t];
      const desc = (t==="combat") ? "æ•µã¨æˆ¦ã†ï¼ˆå‹ã¦ã°å ±é…¬ï¼‰"
                 : (t==="treasure") ? "ãƒ¬ãƒªãƒƒã‚¯3æŠï¼ˆ1ã¤å…¥æ‰‹ï¼‰"
                 : (t==="event") ? "ä¸€ç™ºé€†è»¢orå¤§äº‹æ•…"
                 : (t==="rest") ? "HPå›å¾©ï¼ˆæˆ¦é—˜ãªã—ï¼‰"
                 : "ã‚³ã‚¤ãƒ³ã§å¼·åŒ–ï¼ˆæˆ¦é—˜ãªã—ï¼‰";
      const cls = (t==="combat") ? "primary"
               : (t==="treasure") ? "warnbtn"
               : (t==="event") ? "badbtn"
               : (t==="rest") ? "okbtn"
               : "okbtn";
      return {
        label:`${info.icon} <b>${info.name}</b> <span class="muted">â€” ${desc}</span>`,
        cls,
        onClick: ()=> enterRoom(t)
      };
    }));
  }

  function enterRoom(t){
    if(t!=="combat" && !S.inBossPrep) S.nonCombatUsed = true; // âœ… ãƒœã‚¹å‰æº–å‚™ä¸­ã¯æ±šã•ãªã„
    if(t==="combat") return screenCombatStart(false);
    if(t==="treasure") return screenTreasure();
    if(t==="event") return screenEvent();
    if(t==="rest") return screenRest();
    if(t==="shop") return screenShop();
  }

  // -------------- ç”»é¢ï¼šãƒœã‚¹å‰æº–å‚™éƒ¨å±‹ --------------
  function screenBossPrep(){
    S.mode = "bossPrep";
    S.inBossPrep = true;
  
    // âœ… ã“ã®éšã§ã€Œæœ€åˆã«ãƒœã‚¹å‰ã«å…¥ã£ãŸæ™‚ã ã‘ã€åˆæœŸåŒ–ã™ã‚‹
    if(S.bossPrepInitFloor !== S.floor){
      S.bossPrepInitFloor = S.floor;
      S.bossPrepRestUsed = false;
      S.bossPrepShopUsed = false;
      S.bossPrepEventUsed = false;
    }
  
    ui();
  
    const status = [
      `å›å¾©:${S.bossPrepRestUsed ? "æ¸ˆ" : "æœª"}`,
      `å•†äºº:${S.bossPrepShopUsed ? "æ¸ˆ" : "æœª"}`,
      `ã‚¤ãƒ™ãƒ³ãƒˆ:${S.bossPrepEventUsed ? "æ¸ˆ" : "æœª"}`
    ].join(" / ");
  
    log(`<span class="pill warn">ãƒœã‚¹å‰</span>ã“ã®å…ˆã«å¼·æ•µã®æ°—é…â€¦ã€‚æº–å‚™ã™ã‚‹ï¼Ÿ<br><small>${status}</small>`);
  
    setChoices([
      {
        label:`ğŸ›ï¸ å›å¾© <span class="muted">ï¼ˆ1å›ã¾ã§ï¼‰</span>`,
        cls:"okbtn",
        disabled: S.bossPrepRestUsed,
        onClick: ()=>{
          S.bossPrepRestUsed = true;
  
          const baseHeal = r(6, 10);
          let heal = applyRelicsHook("onRest", baseHeal);
          S.hp = clamp(S.hp + heal, 0, S.maxhp);
          ui();
  
          log(`<span class="pill ok">æº–å‚™</span>HP+${heal}ã€‚`);
          setChoices([{label:"æˆ»ã‚‹", cls:"primary", onClick: screenBossPrep}]);
        }
      },
      {
        label:`ğŸ›’ å•†äºº <span class="muted">ï¼ˆ1å›ã¾ã§ / è¤‡æ•°è³¼å…¥OKï¼‰</span>`,
        cls:"okbtn",
        disabled: S.bossPrepShopUsed,
        onClick: ()=>{
          S.bossPrepShopUsed = true;
          screenShop(); // âœ… ä¸­ã§ã€Œå‡ºã‚‹ã€æŠ¼ã—ãŸã‚‰ bossPrep ã«æˆ»ã™ã‚ˆã†ã«å¾Œè¿°ã§æ”¹é€ ã—ã¾ã™
        }
      },
      {
        label:`â“ ã‚¤ãƒ™ãƒ³ãƒˆ <span class="muted">ï¼ˆä»»æ„ / 1å›ã¾ã§ï¼‰</span>`,
        cls:"badbtn",
        disabled: S.bossPrepEventUsed,
        onClick: ()=>{
          S.bossPrepEventUsed = true;
          screenEvent(); // âœ… é€²ã‚€ã‚’æŠ¼ã™ã¨ proceedAfterNonCombat() ã§ bossPrep ã«æˆ»ã‚‹
        }
      },
      {
        label:`âš”ï¸ ãƒœã‚¹ã¸ <span class="muted">ï¼ˆæº–å‚™å®Œäº†ï¼‰</span>`,
        cls:"warnbtn",
        onClick: startBossFromPrep
      },
    ]);
  }

  // -------------- ãƒœã‚¹é–‹å§‹ç”¨ --------------
  function startBossFromPrep(){
    S.inBossPrep = false;
    S.bossPrepDone = S.floor;   // âœ… ã“ã®éšã®æº–å‚™ã¯æ¸ˆã‚“ã 
    screenCombatStart(true);
  }
  
  // -------------- æˆ¦é—˜ --------------
  function screenCombatStart(isBoss){
    S.mode = "combat";
    S.block = 0;
    S.enemy = isBoss ? bossEnemyForFloor(S.floor) : enemyForFloor(S.floor);
    if(isBoss) playSE("boss");
    
    // å•†äººã§è²·ã£ãŸã€Œé–‹å§‹æ™‚é˜²å¾¡ã€åæ˜ 
    if(S.tempStartBlock){
      S.block += S.tempStartBlock;
      S.tempStartBlock = 0;
    }
    rollEnemyIntent();
    ui();
    const bossTxt = isBoss ? ` <span class="pill warn">BOSS</span>` : "";
    log(`<span class="pill neu">æˆ¦é—˜</span>${bossTxt}${S.enemy.name}ãŒç¾ã‚ŒãŸï¼<br><small>æ•µã®æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
    setChoices(makeCombatChoices());
    playBGM();
    setIdle(true);
    // æˆ¦é—˜é–‹å§‹ï¼šé¸æŠã‚­ãƒ£ãƒ©ã«å¿œã˜ã¦è¡¨ç¤ºåˆ‡æ›¿
    const p = PLAYERS.find(x => x.id === S.playerId);
    if(p && p.live2d){
      document.getElementById("live2dWrap").classList.remove("hidden");
      document.getElementById("playerImg").style.visibility = "hidden";
      // è¿½åŠ ï¼š2ãƒ•ãƒ¬ãƒ¼ãƒ å¾…ã£ã¦ã‹ã‚‰å¼·åˆ¶ãƒªã‚µã‚¤ã‚ºï¼ˆç¢ºå®Ÿï¼‰
      requestAnimationFrame(() => requestAnimationFrame(() => L2D.resize()));
    }else{
      document.getElementById("live2dWrap").classList.add("hidden");
      document.getElementById("playerImg").style.visibility = "visible";
    }
  }

  function makeCombatChoices(){
    const atkMin = 4 + Math.floor(S.floor/2);
    const atkMax = 7 + Math.floor(S.floor/2);

    const doPotion = () => {
      if(!S.potion){
        S.last = "âŒ ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ãªã„";
        ui();
        setChoices(makeCombatChoices());
        return;
      }
    
      const res = usePotion();   // â† usePotion() ã®ä¸­ã§ S.potion = null ã«ãªã£ã¦æ¶ˆè²»ã•ã‚Œã‚‹
      S.last = res.msg;
      ui();
    
      // âœ… ã‚¿ãƒ¼ãƒ³æ¶ˆè²»ã—ãªã„ï¼šæ•µã‚¿ãƒ¼ãƒ³ã¸è¡Œã‹ãšã€ãã®ã¾ã¾é¸æŠè‚¢ã‚’å‡ºã—ç›´ã™
      log(`${S.last}<br><small>ï¼ˆãƒãƒ¼ã‚·ãƒ§ãƒ³ã¯ã‚¿ãƒ¼ãƒ³ã‚’æ¶ˆè²»ã—ãªã„ï¼‰</small>`);
      setChoices(makeCombatChoices());
      setIdle(true);
    };
    
    const doAttack = () => {
      L2D.onAction("attack");
      let dmg = r(atkMin, atkMax);
      playAnim(playerWrap, "attack", 220);         // è¸ã¿è¾¼ã¿
      playAnim(enemyWrap, "hurt", 260);            // è¢«å¼¾ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      playAnim(enemyWrap, "knockback", 200);       // ãƒãƒƒã‚¯ãƒãƒƒã‚¯
      
      playSE("attack");
      // ã€Œä¼‘æ†©ï¼šç ”ãã€ä¸€æ™‚ãƒãƒ•ï¼ˆæ¬¡ã®æ”»æ’ƒã ã‘+4ï¼‰
      if(S.tempSharpen){
        dmg += 4;
        S.tempSharpen = false;
      }

      dmg = applyRelicsHook("onAtk", dmg);
      if(S.pStatus.weaken>0) dmg = Math.max(0, dmg - 2);
      S.enemy.hp = clamp(S.enemy.hp - dmg, 0, S.enemy.maxhp);
      spawnFloatText(enemyWrap, `-${dmg}`, "dmg", { big: dmg >= 12 });
      S.last = `ã‚ãªãŸã®æ”»æ’ƒï¼ æ•µã« <b>${dmg}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`;
      gainFocus(1);
      afterPlayerAction();
    };

    const doGuard = () => {
      L2D.onAction("guard");
      let b = r(5, 8) + S.floor;
      playSE("guard");
      b = applyRelicsHook("onBlock", b);
      S.block = b;
      spawnFloatText(playerWrap, `BLOCK +${b}`, "block");
      gainFocus(2);
      S.last = `é˜²å¾¡ï¼ æ¬¡ã®è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ <b>${b}</b> è»½æ¸›ã€‚`;
      afterPlayerAction();
    };

    const doHeal = () => {
      L2D.onAction("heal");
      let h = r(4, 7);
      playSE("heal");
      h = applyRelicsHook("onHeal", h);
      S.hp = clamp(S.hp + h, 0, S.maxhp);
      spawnFloatText(playerWrap, `+${h}`, "heal");
      // å›å¾©ã®è¿½åŠ åŠ¹æœï¼šæ¬¡ã®è¢«ãƒ€ãƒ¡ã‚’å›ºå®šã§-2ï¼ˆãƒ•ãƒ­ã‚¢ã§å°‘ã—ä¼¸ã°ã™ï¼‰
      S.healWard = 2 + Math.floor(S.floor / 3); // ä¾‹: 1-2F=2, 3-5F=3, 6-8F=4
      gainFocus(1);
      S.last = `å›å¾©ï¼ HPã‚’ <b>${h}</b> å›å¾©ã€‚<br><small>åŠ è­·ï¼šæ¬¡ã®è¢«ãƒ€ãƒ¡ -<b>${S.healWard}</b></small>`;
      afterPlayerAction();
    };

    const doEvade = () => {
      L2D.onAction("dodge");
      // æ¬¡ã®è¢«ãƒ€ãƒ¡ã‚’60%è»½æ¸›ï¼ˆå¼·ã„ã®ã§å›ºå®šã§60%ãã‚‰ã„ãŒæ‰±ã„ã‚„ã™ã„ï¼‰
      S.evadeRate = 0.60;
      gainFocus(2);
      S.last = `ğŸª½ å›é¿ã®æ§‹ãˆï¼ æ¬¡ã®è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ <b>60%</b> è»½æ¸›ã€‚`;
      afterPlayerAction();
    };

    const doStrongAttack = () => {
      L2D.onAction("strong");
      const cost = 3;
      if(!spendFocus(cost)){
        S.last = `âŒ é›†ä¸­ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰`;
        ui();
        setChoices(makeCombatChoices());
        return;
      }
    
      // é€šå¸¸æ”»æ’ƒã‚ˆã‚Šå°‘ã—å¼·ã„ç¨‹åº¦ï¼ˆå¼·ã™ãã‚‹ã¨ãƒŒãƒ«ããªã‚‹ã®ã§æ§ãˆã‚ï¼‰
      let dmg = r(atkMin, atkMax) + 5;

      playAnim(playerWrap, "attack", 220);
      playAnim(enemyWrap, "hurt", 260);
      playAnim(enemyWrap, "knockback", 200);
      playSE("attack");

      if(S.tempSharpen){
        dmg += 4;
        S.tempSharpen = false;
      }

      dmg = applyRelicsHook("onAtk", dmg);
      if(S.pStatus.weaken>0) dmg = Math.max(0, dmg - 2);

      // å°ã•ãªè¿½åŠ åŠ¹æœï¼šæ¬¡ã®æ•µæ”»æ’ƒ -2ï¼ˆâ€œæ”»ã‚ãŸã‚‰å°‘ã—æ¥½ã«ãªã‚‹â€ï¼‰
      S.enemyWeaken = Math.max(S.enemyWeaken, 2);

      S.enemy.hp = clamp(S.enemy.hp - dmg, 0, S.enemy.maxhp);
      spawnFloatText(enemyWrap, `-${dmg}`, "dmg", { big: dmg >= 12 });
      S.last = `ğŸ’¥ å¼·æ”»æ’ƒï¼ æ•µã« <b>${dmg}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚<br><small>åœ§åŠ›ï¼šæ¬¡ã®æ•µæ”»æ’ƒ -<b>${S.enemyWeaken}</b></small>`;
      afterPlayerAction();
    };

    const doBreak = () => {
      const cost = 2;

      // ã€Œæºœã‚ã€ä¸­ã«ã ã‘ä½¿ãˆã‚‹ï¼šå¼·æ”»æ’ƒã‚­ãƒ£ãƒ³ã‚»ãƒ«ç”¨
      if(S.enemyIntentType !== "charge"){
        S.last = `âŒ ãƒ–ãƒ¬ã‚¤ã‚¯ã¯ã€Œæºœã‚ã€ä¸­ã«ã—ã‹ä½¿ãˆãªã„`;
        ui();
        setChoices(makeCombatChoices());
        return;
      }
      if(S.breakCD > 0){
        S.last = `âŒ ãƒ–ãƒ¬ã‚¤ã‚¯ã¯ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ï¼ˆæ®‹ã‚Š${S.breakCD}ï¼‰`;
        ui();
        setChoices(makeCombatChoices());
        return;
      }
      if(!spendFocus(cost)){
        S.last = `âŒ é›†ä¸­ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰`;
        ui();
        setChoices(makeCombatChoices());
        return;
      }

      // æºœã‚ã‚’ä¸­æ–­ï¼šå¼·æ”»æ’ƒäºˆå®šã‚’æ¶ˆã™
      S.enemy._charged = false;
      S.enemy._heavyValue = 0;
      S.enemyIntentType = "normal";
      S.enemyNextHeavy = 0;

      // ã²ã‚‹ã¿ï¼šã“ã®ã‚¿ãƒ¼ãƒ³ã®æ•µè¡Œå‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãŸã ã—CDï¼‹ã‚³ã‚¹ãƒˆã§ç„¡é™ä¸å¯ï¼‰
      S.breakStun = 1;
      S.breakCD = 3;
      S.justUsedBreak = true;

      // æºœã‚ã‚­ãƒ£ãƒ³ã‚»ãƒ«å¾Œã®ã€Œæ¬¡ã®æ”»æ’ƒã€ã‚’ã“ã“ã§1å›ã ã‘æ±ºã‚ã‚‹ï¼ˆè¡¨ç¤ºç”¨ï¼‰
      rollEnemyIntent({ forceNormal: true });
      ui();

      S.last = `ğŸ§± ãƒ–ãƒ¬ã‚¤ã‚¯ï¼ æºœã‚ã‚’ä¸­æ–­ã•ã›ãŸã€‚<br><small>æ•µã¯ã²ã‚‹ã‚“ã§è¡Œå‹•ã§ããªã„ï¼ˆCD:${S.breakCD}ï¼‰</small>`;
      afterPlayerAction();
    };

    const doPoisonStrike = () => {
      const cost = 2;
      if(!spendFocus(cost)){
        S.last = `âŒ é›†ä¸­ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰`;
        ui(); setChoices(makeCombatChoices()); return;
      }
    
      // é€šå¸¸æ”»æ’ƒã‚ˆã‚Šå°‘ã—æ§ãˆã‚
      let dmg = r(atkMin, atkMax) - 1;
      dmg = Math.max(0, dmg);
    
      // æ•µãŒã€Œè„†å¼±ã€ãªã‚‰è¢«ãƒ€ãƒ¡å¢—
      if(S.eStatus.vulnerable > 0) dmg = Math.ceil(dmg * 1.25);
    
      playAnim(playerWrap, "attack", 220);
      playAnim(enemyWrap, "hurt", 260);
      playAnim(enemyWrap, "knockback", 200);
      playSE("attack");
    
      dmg = applyRelicsHook("onAtk", dmg);
      if(S.pStatus.weaken>0) dmg = Math.max(0, dmg - 2);
    
      S.enemy.hp = clamp(S.enemy.hp - dmg, 0, S.enemy.maxhp);
      spawnFloatText(enemyWrap, `-${dmg}`, "dmg", { big: dmg >= 12 });
      
      // âœ… ã“ã“ãŒçŠ¶æ…‹ç•°å¸¸ä»˜ä¸ï¼šæ•µã«æ¯’
      addStatus("enemy", "poison", 3, 2 + Math.floor(S.floor/3));
    
      S.last = `â˜ ï¸ æ¯’åˆƒï¼ æ•µã« <b>${dmg}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ + æ¯’ä»˜ä¸`;
      gainFocus(1);
      afterPlayerAction();
    };
    
    const doBurnFlask = () => {
      const cost = 2;
      if(!spendFocus(cost)){
        S.last = `âŒ é›†ä¸­ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰`;
        ui(); setChoices(makeCombatChoices()); return;
      }
    
      let dmg = r(2, 4) + Math.floor(S.floor/3); // å°ãƒ€ãƒ¡
      if(S.eStatus.vulnerable > 0) dmg = Math.ceil(dmg * 1.25);
    
      playAnim(playerWrap, "attack", 220);
      playAnim(enemyWrap, "hurt", 260);
      playAnim(enemyWrap, "knockback", 200);
      playSE("attack");
    
      dmg = applyRelicsHook("onAtk", dmg);
      if(S.pStatus.weaken>0) dmg = Math.max(0, dmg - 2);
    
      S.enemy.hp = clamp(S.enemy.hp - dmg, 0, S.enemy.maxhp);
      spawnFloatText(enemyWrap, `-${dmg}`, "dmg", { big: dmg >= 12 });
    
      // âœ… æ•µã«ç«å‚·
      addStatus("enemy", "burn", 2, 2 + Math.floor(S.floor/4));
    
      S.last = `ğŸ”¥ ç«ç‚ç“¶ï¼ æ•µã« <b>${dmg}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ + ç«å‚·ä»˜ä¸`;
      gainFocus(1);
      afterPlayerAction();
    };
    
    const doCleanse = () => {
      L2D.onAction("cleanse");
      const cost = 2;
      if(!spendFocus(cost)){
        S.last = `âŒ é›†ä¸­ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰`;
        ui(); setChoices(makeCombatChoices()); return;
      }
    
      // âœ… è‡ªåˆ†ã®çŠ¶æ…‹ç•°å¸¸ã‚’è§£é™¤ï¼ˆå¥½ãã«å¯¾è±¡ã‚’å¢—æ¸›OKï¼‰
      S.pStatus.poison = 0; S.pStatus.poisonDmg = 0;
      S.pStatus.burn = 0;   S.pStatus.burnDmg = 0;
      S.pStatus.weaken = 0;
      S.pStatus.vulnerable = 0;
      // â€»ã‚¹ã‚¿ãƒ³ã¯ã€Œå‹•ã‘ãªã„ã€ãªã®ã§åŸºæœ¬ã¯è§£é™¤ã§ããªã„è¨­è¨ˆãŒè‡ªç„¶ã€‚è§£é™¤ã—ãŸã„ãªã‚‰ã“ã“ã‚‚ 0 ã«ã€‚
    
      // ã¤ã„ã§ã«å°å›å¾© or åŠ è­·ã‚’ä»˜ã‘ã‚‹ã®ã‚‚ã‚¢ãƒª
      S.healWard = Math.max(S.healWard, 2);
    
      S.last = `âœ¨ æµ„åŒ–ï¼ çŠ¶æ…‹ç•°å¸¸ã‚’è§£é™¤ã—ãŸã€‚<br><small>åŠ è­·ï¼šæ¬¡ã®è¢«ãƒ€ãƒ¡ -<b>${S.healWard}</b></small>`;
      afterPlayerAction();
    };
    
    const baseP = 0.55;
    const p = applyRelicsHook("onGambleChance", baseP);

    const doGamble = () => {
      const hit = chance(p);
      const dmg = hit ? r(10, 16) + Math.floor(S.floor/2) : 0;
      const self = hit ? 0 : r(2, 5);
      S.enemy.hp = clamp(S.enemy.hp - dmg, 0, S.enemy.maxhp);
      S.hp = clamp(S.hp - self, 0, S.maxhp);
      S.last = hit
        ? `ğŸ² è³­ã‘æˆåŠŸï¼ <b>${dmg}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`
        : `ğŸ² è³­ã‘å¤±æ•—â€¦ è‡ªåˆ†ã« <b>${self}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚`;
      afterPlayerAction();
    };

    const list = [
      { label:`âš”ï¸ æ”»æ’ƒ <span class="muted">(${atkMin}ã€œ${atkMax})</span>`, cls:"primary", onClick: doAttack },
      { label:`ğŸ›¡ï¸ é˜²å¾¡ <span class="muted">(è»½æ¸› 5ã€œ${8+S.floor}+åŠ¹æœ / é›†ä¸­+2)</span>`, cls:"okbtn", onClick: doGuard },
      { label:`ğŸ’š å›å¾© <span class="muted">(4ã€œ7+åŠ¹æœ / é›†ä¸­+1)</span>`, cls:"okbtn", onClick: doHeal },
      { label:`ğŸª½ å›é¿ <span class="muted">(æ¬¡ã®è¢«ãƒ€ãƒ¡-60% / é›†ä¸­+2)</span>`, cls:"okbtn", onClick: doEvade },
      { label:`ğŸ’¥ å¼·æ”»æ’ƒ <span class="muted">(é›†ä¸­-3 / +5ãƒ€ãƒ¡+åœ§åŠ›)</span>`, cls:"primary", onClick: doStrongAttack,
        disabled: S.focus < 3
      },
      { label:`ğŸ§± ãƒ–ãƒ¬ã‚¤ã‚¯ <span class="muted">(æºœã‚ä¸­ã®ã¿ / é›†ä¸­-2 / CD3)</span>`, cls:"warnbtn", onClick: doBreak,
        disabled: (S.focus < 2) || (S.breakCD > 0) || (S.enemyIntentType !== "charge")
      },
      { label:`â˜ ï¸ æ¯’åˆƒ <span class="muted">(é›†ä¸­-2 / æ¯’ä»˜ä¸)</span>`, cls:"primary", onClick: doPoisonStrike,
        disabled: S.focus < 2
      },
      { label:`ğŸ”¥ ç«ç‚ç“¶ <span class="muted">(é›†ä¸­-2 / ç«å‚·ä»˜ä¸)</span>`, cls:"primary", onClick: doBurnFlask,
        disabled: S.focus < 2
      },
      { label:`âœ¨ æµ„åŒ– <span class="muted">(é›†ä¸­-2 / çŠ¶æ…‹ç•°å¸¸è§£é™¤)</span>`, cls:"okbtn", onClick: doCleanse,
        disabled: S.focus < 2
      },
      {
        label: `ğŸ§ª ãƒãƒ¼ã‚·ãƒ§ãƒ³ä½¿ç”¨ <span class="muted">(${S.potion ? S.potion.name : "ãªã—"})</span>`,
        cls: "okbtn",
        onClick: doPotion,
        disabled: !S.potion
      },
    ];

    if(chance(0.35)){
      const idx = r(0,2);
      list[idx] = { label:`ğŸ² è³­ã‘ <span class="muted">(æˆåŠŸ${Math.round(p*100)}% / å¤±æ•—ã§è‡ªå‚·)</span>`, cls:"badbtn", onClick: doGamble };
    }
    return list;
  }

  function afterPlayerAction(){
    S.turns++;
    if(S.pStatus.weaken>0) S.pStatus.weaken--; // å¼±ä½“ã®æ®‹ã‚Šã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹

    if(S.enemy.hp <= 0){
      S.wins++;

      // LVUP
      const gainXp = S.enemy.boss ? 2 : 1;
      S.xp += gainXp;
      checkLevelUp();
      
      // å ±é…¬ï¼šã‚³ã‚¤ãƒ³
      let gold = r(8, 14) + S.floor + (S.enemy.boss ? 10 : 0);
      gold = applyRelicsHook("onGainGold", gold, "combat");
      S.gold += gold;

      applyRelicsHook("onWin", 0);
      ui();

      // âœ… ãƒœã‚¹å‹åˆ©ãªã‚‰ã€Œç¢ºå®šãƒ¬ãƒªãƒƒã‚¯ã€ã¸
      if(S.enemy.boss){
        log(`<span class="pill ok">BOSSæ’ƒç ´</span>${S.last}<br>å ±é…¬ï¼š<b>+${gold}</b>ã‚³ã‚¤ãƒ³<br><small>ãƒœã‚¹å ±é…¬ï¼šç¢ºå®šãƒ¬ãƒªãƒƒã‚¯</small>`);
        S.lastBossFloorCleared = S.floor; // âœ… ã“ã®éšã®ãƒœã‚¹ã¯æ’ƒç ´æ¸ˆã¿
        return screenBossReward(() => {
          if(S.floor >= GOAL){
            return screenVictory();
          }
          S.floor++;
          S.nonCombatUsed = false;
          S.pStatus = { poison:0, poisonDmg:0, burn:0, burnDmg:0, weaken:0, vulnerable:0, stun:0 };
          S.eStatus = { poison:0, poisonDmg:0, burn:0, burnDmg:0, weaken:0, vulnerable:0, stun:0 };
          S.enemyIntentMeta = null;
          S.bossPicked = {};
          return screenChooseRoom();
        });
      }

      // é€šå¸¸å‹åˆ©
      if(S.floor >= GOAL){
        return screenVictory();
      }
      S.floor++;
      S.nonCombatUsed = false;
      log(`<span class="pill ok">æ’ƒç ´</span>${S.last}<br>å ±é…¬ï¼š<b>+${gold}</b>ã‚³ã‚¤ãƒ³<br><small>æ‰‰ã¸æˆ»ã‚‹â€¦</small>`);
      setChoices([{label:"é€²ã‚€", cls:"primary", onClick: screenChooseRoom}]);
      return;
    }

    enemyTurn();
  }

  function checkLevelUp(){
    while(S.xp >= S.xpNeed){
      S.xp -= S.xpNeed;
      S.level++;
      S.xpNeed = Math.floor(S.xpNeed * 1.35) + 1;
  
      const upHp = 3;
      S.maxhp += upHp;
      S.hp = clamp(S.hp + upHp, 0, S.maxhp);
  
      // ãŸã¾ã«é›†ä¸­ä¸Šé™ã‚‚ä¼¸ã°ã™ï¼ˆä¾‹ï¼š2Lvã”ã¨ï¼‰
      if(S.level % 2 === 0){
        S.focusMax = Math.min(10, S.focusMax + 1);
      }
  
      // ãƒ­ã‚°è¡¨ç¤ºï¼ˆå¥½ã¿ã§ï¼‰
      $("log").innerHTML = `ğŸŒŸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ Lv${S.level}ï¼ˆæœ€å¤§HP+${upHp}ï¼‰<br>` + $("log").innerHTML;
    }
  }
  
  function processEnemyStatusesAtTurnStart(){
    const lines = [];
  
    // DOTï¼ˆæ¯’/ç«å‚·ï¼‰
    if(S.eStatus.poison > 0){
      const base = S.eStatus.poisonDmg || (2 + Math.floor(S.floor/3));
    
      // âœ…ã“ã“ã§å€ç‡ã‚’å–ã‚‹ï¼ˆãªã‘ã‚Œã°1.0ï¼‰
      const mult = (S.enemy?.dotMult?.poison ?? 1.0);
    
      // âœ…å€ç‡åæ˜ ã—ãŸæœ€çµ‚ãƒ€ãƒ¡ãƒ¼ã‚¸
      const d = Math.max(0, Math.round(base * mult));
    
      S.enemy.hp = clamp(S.enemy.hp - d, 0, S.enemy.maxhp);
      S.eStatus.poison--;
      lines.push(`â˜ ï¸ æ•µã¯æ¯’ã§ <b>${d}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸${mult!==1 ? `ï¼ˆå€ç‡x${mult}ï¼‰` : ""}`);
    
      spawnFloatText(enemyWrap, `-${d}`, "dot");
    }
    if(S.eStatus.burn > 0){
      const base = S.eStatus.burnDmg || (2 + Math.floor(S.floor/4));
      const mult = (S.enemy?.dotMult?.burn ?? 1.0);
      const d = Math.max(0, Math.round(base * mult));
    
      S.enemy.hp = clamp(S.enemy.hp - d, 0, S.enemy.maxhp);
      S.eStatus.burn--;
      lines.push(`ğŸ”¥ æ•µã¯ç«å‚·ã§ <b>${d}</b> ãƒ€ãƒ¡ãƒ¼ã‚¸${mult!==1 ? `ï¼ˆå€ç‡x${mult}ï¼‰` : ""}`);
    
      spawnFloatText(enemyWrap, `-${d}`, "dot");
    }
  
    if(lines.length){
      $("log").innerHTML = lines.join("<br>") + "<br>" + $("log").innerHTML;
    }
  
    ui();
  
    // DOTã§å€’ã‚ŒãŸ
    if(S.enemy.hp <= 0){
      // ã“ã“ã§ã€Œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‹åˆ©å‡¦ç†ã€ã«ç¹‹ãå¿…è¦ãŒã‚ã‚‹ã®ã§ã€æˆ¦é—˜å‹åˆ©ãƒ«ãƒ¼ãƒˆã«ä¹—ã›ã‚‹
      S.last = `çŠ¶æ…‹ç•°å¸¸ã§æ•µãŒå€’ã‚ŒãŸï¼`;
      afterPlayerAction(); // æ—¢å­˜ã®å‹åˆ©å‡¦ç†ã¸
      return true; // ã‚‚ã†æ•µã‚¿ãƒ¼ãƒ³ç¶šè¡Œã—ãªã„
    }
  
    // ã‚¹ã‚¿ãƒ³ï¼šæ•µè¡Œå‹•ã‚¹ã‚­ãƒƒãƒ—
    if(S.eStatus.stun > 0){
      S.eStatus.stun--;
      if(S.eStatus.weaken > 0) S.eStatus.weaken--; // âœ… è¿½åŠ 
      tickCooldownsSafe();
      rollEnemyIntent({ forceNormal: true }); // ã‚¹ã‚¿ãƒ³æ˜ã‘ã¯é€šå¸¸ã«å¯„ã›ã‚‹ï¼ˆå¥½ã¿ï¼‰
      ui();
      log(`${S.last}<br>ğŸ˜µ æ•µã¯ã‚¹ã‚¿ãƒ³ã—ã¦å‹•ã‘ãªã„ï¼<br><small>æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
      presentPlayerChoices();
      return true;
    }
  
    return false;
  }
  
  function enemyTurn(){
    // âœ… å…ˆã«æ•µã®çŠ¶æ…‹ç•°å¸¸ï¼ˆDOT/ã‚¹ã‚¿ãƒ³ï¼‰ã‚’å‡¦ç†
    if(processEnemyStatusesAtTurnStart()) return;
    // 1) ãƒ–ãƒ¬ã‚¤ã‚¯ã®ã²ã‚‹ã¿ï¼šæ•µã®è¡Œå‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if(S.breakStun > 0){
      S.breakStun--;
      if(S.eStatus.weaken > 0) S.eStatus.weaken--; // âœ… è¿½åŠ 
      tickCooldownsSafe();  // âœ… ã“ã“ã§CDé€²è¡Œï¼ˆãŸã ã—ãƒ–ãƒ¬ã‚¤ã‚¯ç›´å¾Œã¯æ­¢ã¾ã‚‹ï¼‰

      // âŒ rollEnemyIntent(); ã¯ã—ãªã„ï¼ˆdoBreakã§æ—¢ã«1å›æ±ºã‚ãŸï¼‰
      ui();
      log(`${S.last}<br>æ•µã¯ã²ã‚‹ã‚“ã§å‹•ã‘ãªã„ï¼<br><small>æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
      presentPlayerChoices();
      return;
    }

    // 2) æºœã‚ã‚¿ãƒ¼ãƒ³ï¼šæ”»æ’ƒã—ãªã„ï¼ˆæ¬¡ã«å¼·æ”»æ’ƒãŒæ¥ã‚‹ï¼‰
    if(S.enemyIntentType === "charge"){
      if(S.eStatus.weaken > 0) S.eStatus.weaken--; // âœ… è¿½åŠ 
      tickCooldownsSafe();
      rollEnemyIntent(); // æ¬¡ï¼ˆheavyç­‰ï¼‰ã‚’æ±ºã‚ã‚‹
      ui();
      log(`${S.last}<br>æ•µã¯åŠ›ã‚’æºœã‚ã¦ã„ã‚‹â€¦ï¼<br><small>æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
      presentPlayerChoices();
      return;
    }

    // 3) åå‹•ï¼ˆéš™ï¼‰ã‚¿ãƒ¼ãƒ³ï¼šæ”»æ’ƒã—ãªã„ï¼ˆå¼·æ”»æ’ƒã®æ¬¡ã«æ¥ã‚‹ï¼‰
    if(S.enemyIntentType === "recoil"){
      if(S.eStatus.weaken > 0) S.eStatus.weaken--; // âœ… è¿½åŠ 
      tickCooldownsSafe();
      rollEnemyIntent(); // æ¬¡ï¼ˆnormalï¼‰ã‚’æ±ºã‚ã‚‹
      ui();
      log(`${S.last}<br>æ•µã¯åå‹•ã§éš™ã ã‚‰ã‘ã ï¼<br><small>æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
      presentPlayerChoices();
      return;
    }

    // 3.5) ç‰¹æ®Šã‚¹ã‚­ãƒ«ï¼ˆãƒ€ãƒ¡ãªã—ï¼‰
    if(S.enemyIntentMeta && S.enemyIntentMeta.noDamage){
      const ap = S.enemyIntentMeta.apply || {};
      if(ap.poison) addStatus("player","poison", ap.poison.turns, ap.poison.dmg||0);
      if(ap.burn)   addStatus("player","burn",   ap.burn.turns,   ap.burn.dmg||0);
      if(ap.weaken) addStatus("player","weaken", ap.weaken.turns);
      if(ap.vulnerable) addStatus("player","vulnerable", ap.vulnerable.turns);
      if(ap.stun)  addStatus("player","stun",  ap.stun.turns);

      // æ•µã®å¼±ä½“ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ï¼ˆã‚¹ã‚­ãƒ«è¡Œå‹•ã®å¾Œï¼‰
      if(S.eStatus.weaken > 0) S.eStatus.weaken--; 
      
      tickCooldownsSafe();
      rollEnemyIntent();
      ui();
      log(`${S.last}<br>æ•µã¯ä¸æ°—å‘³ãªè¡“ã‚’æ”¾ã£ãŸâ€¦ï¼<br><small>æ•µã®æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
      presentPlayerChoices();
      return;
    }

    // 4) é€šå¸¸ or å¼·æ”»æ’ƒ
    L2D.onAction("hit");
    playAnim(enemyWrap, "attack", 220);
    playAnim(playerWrap, "hurt", 260);
    playAnim(playerWrap, "knockback", 200);

    const atk = S.enemyIntent;

    // é˜²å¾¡ï¼ˆå›ºå®šè»½æ¸›ï¼‰
    const reduced = Math.min(S.block, atk);
    let dmg = atk - reduced;
    // æ•µãŒå¼±ä½“ãªã‚‰ä¸ãƒ€ãƒ¡æ¸›ï¼ˆæ•µã®æ”»æ’ƒåŠ›ãƒ€ã‚¦ãƒ³ï¼‰
    if(S.eStatus.weaken > 0){
      dmg = Math.max(0, dmg - 2);
    }

    // å¼·æ”»æ’ƒ/åœ§åŠ›ãªã©ã®ã€Œæ¬¡ã®æ•µæ”»æ’ƒ-â—‹ã€
    if(S.enemyWeaken){
      dmg = Math.max(0, dmg - S.enemyWeaken);
      S.enemyWeaken = 0;
    }

    // å›å¾©ã®åŠ è­·ï¼ˆå›ºå®šè»½æ¸›ï¼‰
    if(S.healWard){
      dmg = Math.max(0, dmg - S.healWard);
      S.healWard = 0;
    }

    // å›é¿ï¼ˆå‰²åˆè»½æ¸›ï¼‰
    if(S.evadeRate){
      dmg = Math.floor(dmg * (1 - S.evadeRate));
      S.evadeRate = 0;
    }

    // è„†å¼±ï¼šè¢«ãƒ€ãƒ¡å¢—åŠ 
    if(S.pStatus.vulnerable>0){
      dmg = Math.ceil(dmg * 1.25);
    }

    S.block = 0;
    S.hp = clamp(S.hp - dmg, 0, S.maxhp);

    // âœ… ã“ã“ã‚’è¿½åŠ 
    if(dmg > 0) spawnFloatText(playerWrap, `-${dmg}`, "dmg", { big: dmg >= 12 });
    else spawnFloatText(playerWrap, `BLOCK`, "block");
    
    // è„†å¼±ã®æ®‹ã‚Šã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ï¼ˆæ•µã®æ”»æ’ƒã‚’å—ã‘ãŸå¾Œï¼‰
    if(S.pStatus.vulnerable>0) S.pStatus.vulnerable--;

    // è¿½åŠ åŠ¹æœï¼ˆæ¯’/ç«å‚·/ã‚¹ã‚¿ãƒ³/å¼±ä½“ãªã©ï¼‰
    if(S.enemyIntentMeta && S.enemyIntentMeta.apply){
      const ap = S.enemyIntentMeta.apply;
      if(ap.poison) addStatus("player","poison", ap.poison.turns, ap.poison.dmg||0);
      if(ap.burn)   addStatus("player","burn",   ap.burn.turns,   ap.burn.dmg||0);
      if(ap.weaken) addStatus("player","weaken", ap.weaken.turns);
      if(ap.vulnerable) addStatus("player","vulnerable", ap.vulnerable.turns);
      if(ap.stun)  addStatus("player","stun",  ap.stun.turns);
    }

    // å¸åï¼ˆä¸ãˆãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’å›å¾©ï¼‰
    let drainTxt = "";
    if(S.enemyIntentMeta && S.enemyIntentMeta.drain && S.enemy){
      const heal = Math.ceil(dmg * S.enemyIntentMeta.drain);
      if(heal > 0){
        S.enemy.hp = clamp(S.enemy.hp + heal, 0, S.enemy.maxhp);
        drainTxt = ` <small>ï¼ˆæ•µHP+${heal}ï¼‰</small>`;
      }
    }

    // â˜… å¼·æ”»æ’ƒã ã£ãŸå ´åˆï¼šæ¬¡ã®ã‚¿ãƒ¼ãƒ³ã‚’ã€Œåå‹•ï¼ˆéš™ï¼‰ã€ã«ã™ã‚‹ï¼ˆãƒœã‚¹ã®ã¿ãƒ»å¯¾å¿œãƒœã‚¹ã ã‘ï¼‰
    if(S.enemy?.boss && S.enemyIntentType === "heavy" && ("_recoil" in S.enemy)){
      S.enemy._recoil = true;
    }

    // æ•µã®å¼±ä½“ã‚¿ãƒ¼ãƒ³ã‚’é€²ã‚ã‚‹ï¼ˆæ•µãŒè¡Œå‹•ã—ãŸå¾Œï¼‰
    if(S.eStatus.weaken > 0) S.eStatus.weaken--;
    
    // ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†å‡¦ç†
    tickCooldownsSafe();
    rollEnemyIntent();
    ui();

    if(S.hp <= 0){
      return screenGameOver(atk, reduced, dmg);
    }

    log(`${S.last}<br>æ•µã®æ”»æ’ƒ ${atk}ï¼ˆè»½æ¸› ${reduced}ï¼‰â†’ è¢«ãƒ€ãƒ¡ ${dmg}${drainTxt}<br><small>æ•µã®æ¬¡ã®æ”»æ’ƒã¯ <b>${$("eintent").textContent}</b></small>`);
    presentPlayerChoices();
  }

  // -------------- âœ… ãƒœã‚¹å ±é…¬ï¼ˆç¢ºå®šãƒ¬ãƒªãƒƒã‚¯ï¼‰ --------------ï¼ˆç¢ºå®šãƒ¬ãƒªãƒƒã‚¯ï¼‰ --------------
  function screenBossReward(onDone){
    playSE("relic");
    S.mode = "bossReward";
    ui();

    if (S.relics.length >= MAX_RELICS) {
      log(`<span class="pill warn">ãƒœã‚¹å ±é…¬</span>ãƒ¬ãƒªãƒƒã‚¯ä¸Šé™ï¼ˆ${MAX_RELICS}ï¼‰ã®ãŸã‚ç²å¾—ã§ããªã„ã€‚`);
      setChoices([{label:"é€²ã‚€", cls:"primary", onClick: onDone}]);
      return;
    }

    const candidates = RELICS.filter(x=>!S.relics.includes(x.id));
    const picks = [];
    while(picks.length < 3 && candidates.length>0){
      const rel = candidates.splice(r(0, candidates.length-1), 1)[0];
      picks.push(rel);
    }

    if(picks.length === 0){
      log(`<span class="pill warn">ãƒœã‚¹å ±é…¬</span>â€¦ã—ã‹ã—ãƒ¬ãƒªãƒƒã‚¯ã¯ã‚‚ã†æ®‹ã£ã¦ã„ãªã„ã€‚`);
      setChoices([{label:"é€²ã‚€", cls:"primary", onClick: onDone}]);
      return;
    }

    log(`<span class="pill warn">ãƒœã‚¹å ±é…¬</span>ãƒ¬ãƒªãƒƒã‚¯ã‚’1ã¤é¸ã¹ã‚‹ã€‚`);

    setChoices(picks.map(rel=>({
      label:`ğŸ† <b>${rel.name}</b><br><span class="muted">${rel.desc}</span>`,
      cls:"warnbtn",
      onClick: ()=>{
        S.relics.push(rel.id);
        if(typeof rel.onPick === "function") rel.onPick(S);
        ui();
        log(`<span class="pill warn">å…¥æ‰‹</span><b>${rel.name}</b> ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼<br><small>${rel.desc}</small>`);
        setChoices([{label:"é€²ã‚€", cls:"primary", onClick: onDone}]);
      }
    })));
  }

  // -------------- å®ç®±ï¼ˆãƒ¬ãƒªãƒƒã‚¯3æŠï¼‰ --------------
  function screenTreasure(){
    // ãƒ¬ãƒªãƒƒã‚¯ä¸Šé™ãƒã‚§ãƒƒã‚¯
    if (S.relics.length >= MAX_RELICS) {
      log(`<span class="pill warn">å®ç®±</span>ãƒ¬ãƒªãƒƒã‚¯ä¸Šé™ï¼ˆ${MAX_RELICS}ï¼‰ã®ãŸã‚ç²å¾—ã§ããªã„ã€‚`);
      setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      return;
    }
    
    playSE("relic");
    S.mode = "treasure";
    ui();

    // å®ç®±ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã“ã®éƒ¨å±‹ã«å…¥ã£ãŸå›æ•°ï¼‰
    S.treasureCount++;

    const candidates = RELICS.filter(x=>!S.relics.includes(x.id));
    const picks = [];
    while(picks.length < 3 && candidates.length>0){
      const rel = candidates.splice(r(0, candidates.length-1), 1)[0];
      picks.push(rel);
    }

    if(picks.length === 0){
      log(`<span class="pill warn">å®ç®±</span>â€¦ã—ã‹ã—ãƒ¬ãƒªãƒƒã‚¯ã¯ã‚‚ã†æ®‹ã£ã¦ã„ãªã„ã€‚`);
      setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      return;
    }

    let g = r(6, 10);
    g = applyRelicsHook("onGainGold", g, "treasure");
    S.gold += g;

    log(`<span class="pill warn">å®ç®±</span>å®ç®±ã‚’è¦‹ã¤ã‘ãŸï¼ <b>+${g}</b>ã‚³ã‚¤ãƒ³<br><small>ãƒ¬ãƒªãƒƒã‚¯ã‚’1ã¤é¸ã¹ã‚‹ã€‚</small>`);

    setChoices(picks.map(rel=>({
      label:`ğŸ§° <b>${rel.name}</b><br><span class="muted">${rel.desc}</span>`,
      cls:"warnbtn",
      onClick: ()=>{
        S.relics.push(rel.id);
        if(typeof rel.onPick === "function") rel.onPick(S);
        ui();
        log(`<span class="pill warn">å…¥æ‰‹</span><b>${rel.name}</b> ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼<br><small>${rel.desc}</small>`);
        setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      }
    })));
  }

  // -------------- ã‚¤ãƒ™ãƒ³ãƒˆ --------------
  function screenEvent(){
    S.mode = "event";
    ui();

    const ev = pick(["fountain","altar","stranger","trap"]);
    if(ev==="fountain"){
      log(`<span class="pill bad">ã‚¤ãƒ™ãƒ³ãƒˆ</span>æ€ªã—ã„æ³‰ãŒã‚ã‚‹â€¦ã©ã†ã™ã‚‹ï¼Ÿ`);
      setChoices([
        { label:`ğŸ’§ é£²ã‚€ <span class="muted">ï¼ˆå›å¾© or æ¯’ï¼‰</span>`, cls:"badbtn", onClick: ()=>{
          if(chance(0.55)){
            let h = r(7, 12);
            h = applyRelicsHook("onHeal", h);
            S.hp = clamp(S.hp + h, 0, S.maxhp);
            S.last = `æ³‰ã¯ç™’ã‚„ã—ã ã£ãŸï¼ HP+${h}`;
            // 20%ã§ãƒãƒ¼ã‚·ãƒ§ãƒ³æ‹¾ã†ï¼ˆæ‰€æŒæ ãŒç©ºãªã‚‰ï¼‰
            if(!S.potion && Math.random() < 0.20){
              givePotion(Math.random() < 0.5 ? "heal" : "cleanse");
              S.last += ` + ğŸ§ª${S.potion.name}ã‚’æ‹¾ã£ãŸï¼`;
            }
          }else{
            const d = r(5, 9);
            S.hp = clamp(S.hp - d, 0, S.maxhp);
            S.last = `æ¯’ã ã£ãŸâ€¦ HP-${d}`;
          }
          ui();
          if(S.hp<=0) return defeatFromEvent();
          log(`<span class="pill bad">çµæœ</span>${S.last}`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
        { label:`ğŸš¶ ç«‹ã¡å»ã‚‹ <span class="muted">ï¼ˆå®‰å…¨ï¼‰</span>`, cls:"okbtn", onClick: ()=>{
          log(`<span class="pill neu">å›é¿</span>ä½•ã‚‚ã—ãªã„ã®ãŒä¸€ç•ªã€‚`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
      ]);
      return;
    }

    if(ev==="altar"){
      log(`<span class="pill bad">ã‚¤ãƒ™ãƒ³ãƒˆ</span>å¤ã„ç¥­å£‡ãŒã‚ã‚‹ã€‚ã€Œæ§ã’ã‚ˆã€ã¨æ›¸ã„ã¦ã‚ã‚‹â€¦`);
      setChoices([
        { label:`ğŸ©¸ HPã‚’æ§ã’ã‚‹ <span class="muted">ï¼ˆæœ€å¤§HP+2 & ã‚³ã‚¤ãƒ³+10ï¼‰</span>`, cls:"badbtn", onClick: ()=>{
          const d = r(3,6);
          S.hp = clamp(S.hp - d, 0, S.maxhp);
          S.maxhp += 2;
          let g = 10;
          g = applyRelicsHook("onGainGold", g, "event");
          S.gold += g;
          S.last = `HP-${d}ã€æœ€å¤§HP+2ã€ã‚³ã‚¤ãƒ³+${g}`;
          ui();
          if(S.hp<=0) return defeatFromEvent();
          log(`<span class="pill bad">çµæœ</span>${S.last}`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
        { label:`ğŸª™ ã‚³ã‚¤ãƒ³ã‚’æ§ã’ã‚‹ <span class="muted">ï¼ˆãƒ¬ãƒªãƒƒã‚¯3æŠï¼‰</span>`, cls:"warnbtn", onClick: ()=>{
          const cost = 12;
          if(S.gold < cost){
            log(`<span class="pill warn">ä¸è¶³</span>ã‚³ã‚¤ãƒ³ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost} / æ‰€æŒ${S.gold}ï¼‰ã€‚`);
            setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
            return;
          }
          S.gold -= cost;
          ui();
          screenTreasure();
        }},
        { label:`ğŸš¶ ç«‹ã¡å»ã‚‹`, cls:"okbtn", onClick: ()=>{
          log(`<span class="pill neu">å›é¿</span>é¢å€’ã«ã¯é–¢ã‚ã‚‰ãªã„ã€‚`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
      ]);
      return;
    }

    if(ev==="stranger"){
      log(`<span class="pill bad">ã‚¤ãƒ™ãƒ³ãƒˆ</span>è¬ã®è¡Œå•†äººãŒè¿‘ã¥ã„ã¦ãã‚‹â€¦ã€Œå‹è² ã—ãªã„ã‹ï¼Ÿã€`);
      setChoices([
        { label:`ğŸ² ã‚³ã‚¤ãƒ³10ã§å‹è²  <span class="muted">ï¼ˆå‹ã¦ã°+25 / è² ã‘ã§0ï¼‰</span>`, cls:"badbtn", onClick: ()=>{
          const bet = 10;
          if(S.gold < bet){
            log(`<span class="pill warn">ä¸è¶³</span>ã‚³ã‚¤ãƒ³ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${bet}ï¼‰ã€‚`);
            setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
            return;
          }
          S.gold -= bet;
          const win = chance(0.45);
          let gain = 0;
          if(win){
            gain = 25;
            gain = applyRelicsHook("onGainGold", gain, "event");
            S.gold += gain;
            S.last = `å‹ã£ãŸï¼ +${gain}ã‚³ã‚¤ãƒ³`;
          }else{
            S.last = `è² ã‘ãŸâ€¦ ä½•ã‚‚å¾—ã‚‰ã‚Œãªã„`;
          }
          ui();
          log(`<span class="pill bad">çµæœ</span>${S.last}`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
        { label:`ğŸ’š äº¤æ› <span class="muted">ï¼ˆHP+6 ãŸã ã—ã‚³ã‚¤ãƒ³-8ï¼‰</span>`, cls:"okbtn", onClick: ()=>{
          const cost = 8;
          if(S.gold < cost){
            log(`<span class="pill warn">ä¸è¶³</span>ã‚³ã‚¤ãƒ³ãŒè¶³ã‚Šãªã„ï¼ˆå¿…è¦${cost}ï¼‰ã€‚`);
            setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
            return;
          }
          S.gold -= cost;
          let h = 6;
          h = applyRelicsHook("onHeal", h);
          S.hp = clamp(S.hp + h, 0, S.maxhp);
          ui();
          log(`<span class="pill ok">çµæœ</span>HP+${h} / ã‚³ã‚¤ãƒ³-${cost}`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
        { label:`ğŸš¶ ç«‹ã¡å»ã‚‹`, cls:"okbtn", onClick: ()=>{
          log(`<span class="pill neu">å›é¿</span>é–¢ã‚ã‚‰ãªã„ã€‚`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }},
      ]);
      return;
    }

    // trap
    log(`<span class="pill bad">ã‚¤ãƒ™ãƒ³ãƒˆ</span>åºŠãŒæ€ªã—ã„â€¦ç½ ã‹ã‚‚ã—ã‚Œãªã„ã€‚ã©ã†å‹•ãï¼Ÿ`);
    setChoices([
      { label:`ğŸ§  æ…é‡ã«é€²ã‚€ <span class="muted">ï¼ˆè¢«å®³å° / æ™‚ã€…ã‚³ã‚¤ãƒ³ï¼‰</span>`, cls:"okbtn", onClick: ()=>{
        if(chance(0.35)){
          let g = r(6, 12);
          g = applyRelicsHook("onGainGold", g, "event");
          S.gold += g;
          S.last = `ç½ ã‚’å›é¿ã—ã¤ã¤æ‹¾ã„ç‰©ï¼ +${g}ã‚³ã‚¤ãƒ³`;
        }else{
          const d = r(2, 5);
          S.hp = clamp(S.hp - d, 0, S.maxhp);
          S.last = `å°‘ã—å¼•ã£ã‹ã‹ã£ãŸâ€¦ HP-${d}`;
        }
        ui();
        if(S.hp<=0) return defeatFromEvent();
        log(`<span class="pill bad">çµæœ</span>${S.last}`);
        setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      }},
      { label:`ğŸƒ èµ°ã‚ŠæŠœã‘ã‚‹ <span class="muted">ï¼ˆæˆåŠŸã§å®ç®± / å¤±æ•—ã§å¤§ãƒ€ãƒ¡ï¼‰</span>`, cls:"badbtn", onClick: ()=>{
        if(chance(0.45)){
          S.last = `æˆåŠŸï¼ èµ°ã‚ŠæŠœã‘ãŸå…ˆã«å®ç®±ï¼`;
          ui();
          log(`<span class="pill warn">æˆåŠŸ</span>${S.last}`);
          setChoices([{label:"å®ç®±ã‚’é–‹ã‘ã‚‹", cls:"warnbtn", onClick: screenTreasure}]);
        }else{
          const d = r(6, 10);
          S.hp = clamp(S.hp - d, 0, S.maxhp);
          ui();
          if(S.hp<=0) return defeatFromEvent();
          log(`<span class="pill bad">å¤±æ•—</span>å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸â€¦ HP-${d}`);
          setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
        }
      }},
    ]);
  }

  function defeatFromEvent(){
    S.mode = "gameover";
    ui();
    log(`<span class="pill bad">æ•—åŒ—</span>ã‚¤ãƒ™ãƒ³ãƒˆã®çµæœã§å€’ã‚ŒãŸâ€¦<br><small>åˆ°é”ï¼šéšå±¤${S.floor}/${GOAL} / å‹åˆ©æ•°:${S.wins} / æ‰‹æ•°:${S.turns}</small>`);
    setChoices([]); // è² ã‘ãŸã‚‰ä¸‹ã®ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã§å†é–‹
  }

  // -------------- éæˆ¦é—˜ã®ã€Œé€²ã‚€ã€ã®æŒ™å‹• --------------
  function proceedAfterNonCombat(){
    if(S.inBossPrep){
      // âœ… ãƒœã‚¹å‰æº–å‚™ä¸­ã¯ã€Œãƒœã‚¹å‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹ã€ï¼ˆéšå±¤ã¯é€²ã‚ãªã„ï¼‰
      return screenBossPrep();
    }
    // âœ… é€šå¸¸éšã¯éæˆ¦é—˜ã§éšå±¤ã‚’é€²ã‚ãªã„
    return screenChooseRoom();
  }
  
  // -------------- ä¼‘æ†© --------------
  function screenRest(){
    S.mode = "rest";
    ui();

    const baseHeal = r(6, 10);
    let heal = applyRelicsHook("onRest", baseHeal);
    log(`<span class="pill ok">ä¼‘æ†©</span>å®‰å…¨åœ°å¸¯ã ã€‚ã©ã†ã™ã‚‹ï¼Ÿ`);

    setChoices([
      { label:`ğŸ›ï¸ ä¼‘ã‚€ <span class="muted">(HP+${heal})</span>`, cls:"okbtn", onClick: ()=>{
        S.hp = clamp(S.hp + heal, 0, S.maxhp);
        ui();
        log(`<span class="pill ok">å›å¾©</span>HP+${heal}`);
        setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      }},
      { label:`ğŸ”§ ç ”ã <span class="muted">(æ¬¡ã®æˆ¦é—˜ã®æœ€åˆã®æ”»æ’ƒ+4)</span>`, cls:"primary", onClick: ()=>{
        S.tempSharpen = true;
        ui();
        log(`<span class="pill neu">æº–å‚™</span>æ­¦å™¨ã‚’ç ”ã„ã ã€‚æ¬¡ã®æˆ¦é—˜ã®æœ€åˆã®æ”»æ’ƒãŒå¼·åŒ–ã•ã‚Œã‚‹ã€‚`);
        setChoices([{label:"é€²ã‚€", cls:"primary", onClick: proceedAfterNonCombat}]);
      }},
    ]);
  }

  // -------------- å•†äºº --------------
  function screenShop(){
    S.mode = "shop";
    ui();
  
    // âœ… ã“ã®ã‚·ãƒ§ãƒƒãƒ—è¨ªå•ä¸­ã«è²·ã£ãŸã‚‚ã®ï¼ˆåŒã˜å•†å“ã‚’é‡è¤‡è³¼å…¥ã•ã›ãªã„ãªã‚‰ã“ã‚Œï¼‰
    // ã€Œå°å›å¾©ã¯ä½•å›ã§ã‚‚ã€ã¿ãŸã„ã«ã—ãŸã„å ´åˆã¯ items ã« repeatable:true ã‚’ä»˜ã‘ã¦åˆ¶å¾¡ã§ãã¾ã™
    if(!S._shopBought) S._shopBought = {};
  
    const items = [
      { key:"heal8", name:"å°å›å¾©", desc:"HP+8", cost: 10, repeatable:false, buy: ()=>{
        let h=8; h = applyRelicsHook("onHeal", h);
        S.hp = clamp(S.hp + h, 0, S.maxhp);
      }},
      { key:"maxhp3", name:"æœ€å¤§HPå¼·åŒ–", desc:"æœ€å¤§HP+3ï¼ˆHP+3ï¼‰", cost: 16, repeatable:false, buy: ()=>{
        S.maxhp += 3;
        S.hp = clamp(S.hp + 3, 0, S.maxhp);
      }},
      { key:"block10", name:"é‰„å£", desc:"æ¬¡ã®æˆ¦é—˜é–‹å§‹æ™‚ é˜²å¾¡+10", cost: 12, repeatable:false, buy: ()=>{
        S.tempStartBlock = (S.tempStartBlock || 0) + 10;
      }},
      { key:"p_heal", name:"å›å¾©ãƒãƒ¼ã‚·ãƒ§ãƒ³", desc:"ï¼ˆæ‰€æŒæ 1ï¼‰æˆ¦é—˜ä¸­ã«HP+10", cost: 12, repeatable:false, buy: ()=>{
        const ok = givePotion("heal");
        if(!ok) alert("ã™ã§ã«ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚è²·ãˆãªã„ã‚ˆ");
      }},
      { key:"p_cleanse", name:"æµ„åŒ–ãƒãƒ¼ã‚·ãƒ§ãƒ³", desc:"ï¼ˆæ‰€æŒæ 1ï¼‰æˆ¦é—˜ä¸­ã«çŠ¶æ…‹ç•°å¸¸è§£é™¤", cost: 12, repeatable:false, buy: ()=>{
        const ok = givePotion("cleanse");
        if(!ok) alert("ã™ã§ã«ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚’æŒã£ã¦ã„ã‚‹ãŸã‚è²·ãˆãªã„ã‚ˆ");
      }},
    ];
  
    function renderShop(messageHtml){
      ui();
  
      const header = `<span class="pill ok">å•†äºº</span>ã‚³ã‚¤ãƒ³ã§å¼·åŒ–ã§ãã‚‹ã€‚<br><small>æ‰€æŒã‚³ã‚¤ãƒ³ï¼š<b>${S.gold}</b></small>`;
      log(messageHtml ? (header + `<br><br>${messageHtml}`) : header);
  
      const buyButtons = items.map(it=>{
        const bought = !!S._shopBought[it.key];
        const isPotionItem = (it.key === "p_heal" || it.key === "p_cleanse");
        const canBuy =
          (S.gold >= it.cost) &&
          (!bought || it.repeatable) &&
          (!isPotionItem || !S.potion); // â†è¿½åŠ ï¼šæŒã£ã¦ãŸã‚‰è²·ãˆãªã„
  
        return {
          label:`ğŸ›’ <b>${it.name}</b> <span class="muted">ï¼ˆ${it.cost}ã‚³ã‚¤ãƒ³ï¼‰</span>` +
                (bought && !it.repeatable ? `<br><span class="muted">è³¼å…¥æ¸ˆã¿</span>` : ``) +
                `<br><span class="muted">${it.desc}</span>`,
          cls:"okbtn",
          disabled: !canBuy,
          onClick: ()=>{
            if(!canBuy) return;
            S.gold -= it.cost;
            it.buy();
            if(!it.repeatable) S._shopBought[it.key] = true;
            renderShop(`<span class="pill ok">è³¼å…¥</span>${it.name} ã‚’è³¼å…¥ã—ãŸã€‚`);
          }
        };
      });
  
      setChoices([
        ...buyButtons,
        {
          label: "ğŸšª ã‚·ãƒ§ãƒƒãƒ—ã‚’å‡ºã‚‹",
          cls:"primary",
          onClick: ()=>{
            // âœ… è¨ªå•ãŒçµ‚ã‚ã£ãŸã‚‰è³¼å…¥å±¥æ­´ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ¬¡ã®è¨ªå•ã§ã¯ã¾ãŸè²·ãˆã‚‹ï¼‰
            S._shopBought = {};
            // âœ… ãƒœã‚¹å‰ãªã‚‰bossPrepã¸ã€é€šå¸¸ãªã‚‰æ‰‰é¸æŠã¸ï¼ˆéšå±¤ã¯é€²ã‚ãªã„ï¼‰
            proceedAfterNonCombat();
          }
        }
      ]);
    }
  
    renderShop();
  }

  // -------------- å‹åˆ©/æ•—åŒ— --------------
  function screenVictory(){
    L2D.onAction("win");
    stopBGM();
    playSE("win");
    S.mode = "victory";
    ui();
    log(`<span class="pill ok">å‹åˆ©</span><b>8éšå±¤ã‚’çªç ´ã—ãŸï¼</b><br><small>å‹åˆ©æ•°:${S.wins} / æ‰‹æ•°:${S.turns} / ãƒ¬ãƒªãƒƒã‚¯:${S.relics.length}</small>`);
    setChoices([{label:"ã‚‚ã†ä¸€å›", cls:"primary", onClick:start}]);
  }

  function screenGameOver(atk, reduced, dmg){
    L2D.onAction("lose");
    stopBGM();
    playSE("lose");
    S.mode = "gameover";
    ui();
    log(`<span class="pill bad">æ•—åŒ—</span>${S.last}<br>æ•µã®æ”»æ’ƒ ${atk}ï¼ˆè»½æ¸› ${reduced}ï¼‰â†’ è¢«ãƒ€ãƒ¡ ${dmg}<br><b>HPãŒ0ã«ãªã£ãŸâ€¦</b><br><small>åˆ°é”ï¼šéšå±¤${S.floor}/${GOAL} / å‹åˆ©æ•°:${S.wins} / æ‰‹æ•°:${S.turns}</small>`);
    setChoices([]); // âœ… è² ã‘ãŸã‚‰ãƒªã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã§å†é–‹
  }

  // -------------- å…±æœ‰/å†èµ·å‹• --------------
  function start(){
    S.floor = 1;
    S.maxhp = 20;
    S.hp = 20;
    S.block = 0;
    S.gold = 0;
    S.wins = 0;
    S.relics = [];
    S.enemy = null;
    S.enemyIntent = 0;
    S.turns = 0;
    S.last = "";
    S.tempSharpen = false;
    S.tempStartBlock = 0;
    S.mode = "chooseRoom";
    S.treasureCount = 0;
    S.lastBossFloorCleared = 0;
    S.focus = 0;
    S.focusMax = 6;
    S.breakCD = 0;
    S.breakStun = 0;
    S.enemyWeaken = 0;
    S.evadeRate = 0;
    S.healWard = 0;
    S.enemyIntentType = "normal";
    S.enemyNextHeavy = 0;
    S.justUsedBreak = false;
    S.bossPrepDone = 0;
    S.inBossPrep = false;
    S.nonCombatUsed = false;
    S.bossPrepRestUsed = false;
    S.bossPrepShopUsed = false;
    S.bossPrepEventUsed = false;
    S.bossPrepInitFloor = 0;
    S.potion = null;
    S.bossPicked = {};
    $("pickCard").style.display = "none";
    $("mainCard").style.display = "block";
    ui();
    showPlayerPick();
  }

  $("restart").addEventListener("click", start);
  $("share").addEventListener("click", async ()=>{
    const text =
      `ãƒŸãƒ‹ãƒ­ãƒ¼ã‚°+ï¼šéšå±¤${S.floor}/${GOAL} å‹åˆ©æ•°${S.wins} HP${S.hp}/${S.maxhp} ã‚³ã‚¤ãƒ³${S.gold} ãƒ¬ãƒªãƒƒã‚¯${S.relics.length}`;
    try{
      await navigator.clipboard.writeText(text);
      alert("ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\n" + text);
    }catch(e){
      prompt("ã“ã‚Œã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ã­", text);
    }
  });
  
  document.addEventListener("pointerdown", enableAudioOnce, { once:true });

  start();

  // ===== DEBUG (DevToolsã‹ã‚‰è§¦ã‚‹ç”¨) =====
  window.__DBG = {
    S,
    ui,
    log,
    setChoices,
    screenChooseRoom,
    screenCombatStart,
    screenTreasure,
    screenBossReward,
    enemyTurn,
    afterPlayerAction,
    // å³æ’ƒç ´ï¼ˆæˆ¦é—˜ä¸­ã«ä½¿ã†ï¼‰
    killEnemy(){
      if(!S.enemy) return console.warn("enemyãŒã„ã¾ã›ã‚“");
      S.enemy.hp = 0;
      afterPlayerAction();
    },
    // ãƒœã‚¹éšã¸ãƒ¯ãƒ¼ãƒ—ã—ã¦é–‹å§‹
    goBoss(floor=4){
      S.floor = floor;
      S.lastBossFloorCleared = 0;
      screenChooseRoom(); // ãƒœã‚¹éšãªã‚‰è‡ªå‹•ã§ãƒœã‚¹æˆ¦ã¸å…¥ã‚‹
    },
    // ä»»æ„éšã¸ãƒ¯ãƒ¼ãƒ—ã—ã¦æ‰‰é¸æŠã¸
    goFloor(floor=1){
      S.floor = floor;
      screenChooseRoom();
    },
    // ãƒœã‚¹æ’ƒç ´æ¸ˆã¿æ‰±ã„ã«ã—ã¦é€£æˆ¦ãƒã‚§ãƒƒã‚¯
    markBossCleared(){
      S.lastBossFloorCleared = S.floor;
      console.log("lastBossFloorCleared =", S.lastBossFloorCleared);
    }
  };
  console.log("DEBUG: window.__DBG ready");
  
})();
</script>
</body>
</html>
